Lesson 1:
JAVA Setup
In order to write, compile, and run Java programs you need two pieces of software:
A text editor in which to type your code
Java Development Kit (JDK) to compile and run Java code
The text editor we will begin with is BlueJ. It's an excellent editor designed for education and it includes the JDK so you have nothing else to download and configure. One step. Easy!
Click here to download and install BlueJ
Test your Java installation.
Start BlueJ and select New Project from the menu.
Enter a project name such as "Semester 1" where you will store your Semester 1 work.
For Location, choose a folder on your computer that you can access easily such as your Desktop.
Create a new Java file by clicking the New Class button or selecting Edit-->New Class in the menu.
Name your class HelloWorld and leave the other options as they are. Press OK.
Open the HelloWorld class (shaded box) and delete the existing code. The fastest way to do this is to select all text using Ctrl+A on a PC or Command+A on a Mac.
Then press delete. Replace the code with this:
public class HelloWorld {
   public static void main(String[] args) {
       System.out.println("Hello World!");
   }
}

Close the editor window and go back to the main BlueJ window
Compile your program by pressing the Compile button (shown below). Compiling converts your human-readable Java code into machine code that the computer understands.
Finally, run the program by right-clicking the HelloWorld file (the shaded box) and selecting void main(String[] args)

If everything goes smoothly, you will see "Hello World!" displayed in BlueJ's terminal window.

Install the gpdraw library.
A library is a collection of pre-compiled code organized into a .jar file.
We will be using the grdraw library for easy-to-use drawing capability in our programs.
Download gpdraw.jar and save it to your desktop or wherever you can find it later.
Next, open BlueJ's Preferences menu. (To get there, first make sure you're in the main BlueJ window that has the boxes showing each class. Then, if you're on a PC, select Tools-->Preferences. If you're on a Mac, select BlueJ-->Preferences)
Select the Libraries tab. In the Libraries tab, select Add File and then select gpdraw.jar from wherever you downloaded it.
After pressing OK, you are warned that the changes will not take effect until the Java Virtual Machine (JVM) is restarted. To restart the JVM select Tools-->Reset Java Virtual Machine from the menu or click the u-turn arrow in the bottom right corner of the main BlueJ window.
Test your gpdraw installation.
Make sure you have reset the Java Virtual Machine as described above.
Download DrawingTest.java by right-clicking the link and selecting Save link as (or Save Target As). Choose a location you can find easily.
Add the file to your project by selecting Edit-->Add Class from File in the BlueJ menu.
Compile and run the program the same way you did for HelloWorld.
If everything goes smoothly, you will see a triangle drawn in a window named DrawingTool.


Classes in Java
A class in Java is a code blueprint that defines how objects of that type behave, what kind of attributes it contains, and how to create objects of that type.
A class can be used to create many objects of that class type, each of which will keep track of its own attribute values. The same is true for its behaviors. Each object will have the same set of behaviors but each object might run a behavior differently based on its unique attribute values.
For example, if the color and position of two DrawingTool objects is different then calling the drawCircle behavior will produce two different circles.
Three parts of a class
In Java, a method is a piece of code that defines a behavior.
It is written in the class blueprint. For example, if you told a DrawingTool object to do its drawCircle() behavior, then Java would run the code in the drawCircle() method of the DrawingTool class to produce the circle.
A constructor is a method with the same name as the class. Constuctors are used to create and initialize an object.
An attribute is a class variable that describes an object. Attributes are used to keep track of an object's state.
To summarize, a class is a blueprint for an object and has three parts:

There is another kind of class that doesn't need all three parts.
In order to run a Java program, you need to write a class that has only one method: a main() method. This is discussed later during this lesson.

Object Oriented Programming (OOP)
Object oriented programming is a programming paradigm that attempts to make programs more closely model the way people think about and deal with the world. In OOP, a program consists of a collection of interacting objects. Each object in a program represents an item that has a job to do.
Context
The world in which we live is filled with objects. For example, an object we are all familiar with is a drawing tool such as a pencil or pen.
A drawing tool is an object, which can be described in terms of its attributes and behaviors. Attributes are aspects of an object that describe it, while behaviors are things that the object can do.


The attributes of a pencil are its drawing color, thickness of the line it draws, its location on the drawing surface, etc. Anything that describes an object is called an attribute.
The behaviors of a pencil consist of drawing a circle or rectangle, moving the pencil forward, changing its drawing direction, etc. Anything that an object does is called a behavior.
In Java
In order to use an object within a program, we need to provide a definition for the object. This definition is called a class in Java (see Lesson 1-B). A class can be thought of as a mold, template, or blueprint used to create objects.
The attributes and behaviors of an object can be summarized in a class diagram. A class diagram is an outline of the attributes and behaviors for a given type of object.

Because a class is a blueprint for an object, you can create many objects from one class where each of those objects keeps track of its own attribute values.
For example, you could create two different DrawingTool objects, one at (0, 0) pointing up with a drawing color of blue and another DrawingTool object at (50, 30) pointing down with a drawing color of red.
Both of these objects are built from the same template and have the same kind of attributes and behaviors but each object keeps track of its own values.
The same is true for people! We are all built from the same genetic code that makes us human, but the values of our individual attributes such as height, hair color, gender identification, etc. are unique to each of us.

Main Method
A program is a set of instructions that tells the computer what to do.
In Java, a program consists of one or more classes, where each class can perform different tasks and can tell other classes to perform tasks as well.
Methods
The tasks that a class can perform are defined as methods in the class.
The methods are instructions that accomplish the task, possibly by telling other classes to perform subtasks.
The entry point of every Java application is the main() method.
When you run a Java program, the Java Virtual Machine begins by running the code in the main() method of the class you have chosen.
Every Java application needs at least one main() method. Even large projects with many different parts and files need an entry point - and that entry point is the main() method.
You need to memorize the syntax shown below. Please don't copy and paste the syntax. Type it out by hand - always!
Over time, you will learn the concepts needed to understand meaning of each part of the main() method. An explanation follows below; don't memorize this.
public static void main(String[] args)  


Dissecting main()
Note: You don't have to understand this yet!
public
'public' is an access specifier, which determines who is allowed to access and run this method. 'public', in particular, means that any other class is allowed to run this method, hence the name.
static
This means that this method can be used without creating an object. Unlike standard instance methods, static methods do not use any instance variables or depend in any way on the object’s state and therefore can be called via its class rather than from an object.
(e.g. in order to callMath.random(), you don't need to make a new Math-type object. You can simply call it from the Math class itself.)
void
'void' means this method does not return any value to its caller.
main
This is the name of the method.
'main' is special - it will always be the entry point of a program in Java. If you change this name, then it is no longer the entry point for your program, and Java will complain with the message "main method not found."
This is not apparent in BlueJ because BlueJ allows you to dynamically run any static method rather than always starting in an official main() method. Most Java editors are not as forgiving as BlueJ.
String[] args
This is the parameter. String[] defines the parameter type, and args is the name of the parameter. args, being a name, can technically be named anything you want. Try it!
When you run a Java program, it is possible to pass in parameters via the command line. If parameters are passed in, they are stored in this array as Strings and it's your job to parse the Strings and interpret the meaning of each parameter.
First Program
The smallest possible Java program is a class with a proper class header but no additional code.
public class MyFirstProgram {

}


Create the class shown above in BlueJ.
In the main BlueJ window, click the New Class button or choose Edit-->New Class from the menu.
Name the class MyFirstProgram and note the convention for class names:
Class names should start with a capital letter. (If not, they might be confused with an object reference which you'll understand later.)
Spaces are not allowed. Since spaces are not allowed in class names Java programmers capitalize the first letter of each word to make the name more readable.
Class names must start with a letter but may have numbers anywhere after the first character.
Class names can legally contain a few special characters like underscores and dollar signs but doing so isn't common. The expected convention when naming classes yourself is to use only letters in upper-camel-case WhichIsWhenYouCapitalizeTheStartOfEachWord
We know that each Java program needs a main() method to start in. Therefore, let's add one. Please type this part by hand every time! (In fact, you should be typing everything in this lesson by hand.)
public class MyFirstProgram {

    public static void main(String[] args) {

    }   
}


print vs println
The two basic printing methods in Java are System.out.print() and System.out.println(). The first method prints whatever information you specify and keeps the text cursor on the same line. The second method prints whatever information you specify and then moves the text cursor to the next line.
For example,
public class MyFirstProgram {

        public static void main(String[] args) {    
            System.out.print("Me");
            System.out.print("Like");
            System.out.println("Java");
            System.out.print("Beans");
        }
}


prints this output to the terminal window:
MeLikeJava
Beans


Note that every Java instruction ends with a semicolon. Semicolons are required after each command, and they are not used in class declarations or method headers. Although it is syntactically legal to put more than one command on a single line as shown below, please don't. It's generally poor practice.
System.out.print("Me"); System.out.print("Like"); System.out.println("Java");
System.out.print("Beans");



Also note the curly braces and indenting pattern of the code. A class contains methods and those methods contain commands. Each level is enclosed in curly braces (a starting brace and ending brace) and the contents of each enclosure is indented by one tab to show what it belongs to. BlueJ does a good job of coloring each level of indentation. If the coloring of your program looks strange then you are likely missing a curly brace or have improper indentation.

Using Objects
In order to use an object in a program you must:
Declare the type of object you want to create
Give the object a variable name
Create the object using one of its constructors
Here's an example of declaring and creating a SketchPad object named patty:
SketchPad patty;                    // Declare a SketchPad variable named "patty"
patty = new SketchPad(800, 600);    // Create patty the SketchPad using a SketchPad constructor
                                    // The parameters 800 and 600 represent the width and height of the SketchPad



A constructor is a method with the same name as the class, and it is used to create and initialize an object as shown above.
A method is an action that an object can perform.
Let's add a second object, a DrawingTool, that can draw on patty the SketchPad.
SketchPad patty;                    // Declare a SketchPad variable named "patty"
patty = new SketchPad(800, 600);    // Create patty the SketchPad using a SketchPad constructor
                                    // The parameters 800 and 600 represent the width and height of the SketchPad

DrawingTool bob;                    // Declare a DrawingTool object named bob
bob = new DrawingTool(patty);       // Initizlize bob using one of its constructors.
                                    // Notice that bob is told where to draw (on patty) in the constructor.



Once you have declared and created an object you can then command it to do things using its methods. Methods (behaviors of an object) are the actions an object can perform. Here are some of the methods that DrawingTool objects can perform:
Method name
Parameters
Description
forward
(double distance)
Moves the DrawingTool forward this many pixels
turnRight
(double degrees)
Rotates the DrawingTool clockwise by this many degrees
setWidth
(int width)
Changes the width of the DrawingTool
fillCircle
(double radius)
Draws a filled circle with the given radius


The parameters of a method tell you what kind of information you must provide in order to use the method. Each parameter will be shown in two parts:
datatype parametername
The data type tells you the kind of information you must provide to the method (a type of number, a piece of text, a specific kind of object like a SketchPad, etc.) and the parameter name tells you what the data represents. For example, the method
setWidth(int width)



means that in order to use the setWidth method, you must pass in an integer that represents the new width of the DrawingTool. If you declared and created a DrawingTool named bob then you would change bob's width by saying something like:
bob.setWidth(10);  // Tells bob (who is a kind of DrawingTool) to perform his setWidth() command.



Java has eight primitive data types plus objects that are each their own type. We will study the eight primitive data types in Lesson 3. For now, you should know these:
Data type
What it represents
Examples
int
an integer
5, 312, -18
double
a floating-point number
3.14, -1000, 0.0001 1
String
a piece of text
"Hello Java!", "I like apple 3.14159" 2


In order to use non-default libraries in Java (ex: gpdraw), you must tell Java to include the library by using an import statement at the top of your code. We'll go into more detail later but for now you need to know that in order to use DrawingTool and SketchPad objects you must add the following import statements at the top of your code:
import gpdraw.DrawingTool;  // Imports the DrawingTool class
import gpdraw.SketchPad;    // Imports the SketchPad class



Alternately, you could import everything inside the gpdraw package by using a * wildcard - which means all classes.
import gpdraw.*;  // Imports all classes (DrawingTool and SketchPad) inside the gpdraw.jar library


Putting it altogether
Let's put this all together to write a program that uses a DrawingTool object to draw a square on a SketchPad object. (Follow along in BlueJ!)
Begin by creating a new class in BlueJ. Name the class DrawSquare, remove BlueJ's starter code, and add this code:
public class DrawSquare {

}



Next, add import statements above the class header, so we can use the gpdraw library objects.
import gpdraw.DrawingTool;  // Import DrawingTool class
import gpdraw.SketchPad;    // Import SketchPad class

public class DrawSquare {

}



Add a main method.
import gpdraw.DrawingTool;  // Import DrawingTool class
import gpdraw.SketchPad;    // Import SketchPad class

public class DrawSquare {

     public static void main(String[] args) {

     }
}



Declare variables for a SketchPad and DrawingTool. Then create/initialize them using their constructors.
import gpdraw.DrawingTool;  // Import DrawingTool class
import gpdraw.SketchPad;    // Import SketchPad class

public class DrawSquare {

     public static void main(String[] args) {

          SketchPad paper;  // Declare a SketchPad variable
          DrawingTool pen;  // Declare a DrawingTool variable

          paper = new SketchPad(400, 300);  // Create and initialize the paper
          pen = new DrawingTool(paper);     // Create and initialize the pen
     }

}



Finally, command the DrawingTool object to draw a square using its methods.
import gpdraw.DrawingTool;  // Import DrawingTool class
import gpdraw.SketchPad;    // Import SketchPad class

public class DrawSquare {

     public static void main(String[] args) {

          SketchPad paper;  // Declare a SketchPad variable
          DrawingTool pen;  // Declare a DrawingTool variable

          paper = new SketchPad(400, 300);  // Create and initialize the paper
          pen = new DrawingTool(paper);     // Create and initialize the pen

          pen.setWidth(10);     // Change the pen width to 10

          pen.forward(100);     // Draw left side, 100 pixels long
          pen.turnRight(90);
          pen.forward(100);     // Draw top
          pen.turnRight(90);
          pen.forward(100);     // Draw right
          pen.turnRight(90);
          pen.forward(100);     // Draw bottom
     }

}


Closing thoughts

There is much about the SketchPad and DrawingTool that we don't know yet.
What is the coordinate system?
What is the default thickness?
How do I know what to pass into the constructors?
How do I change the drawing color?
In the next section we will look at the full SketchPad and DrawingTool APIs, which tells you everything you need to know about how to use them.

Note that a double can also hold an integer. ↩
Note that a String is a kind of object, not a primitive ↩
Using APIs
API stands for Application Programming Interface, and it is a document that describes everything you need to know about using a given class. Shown below are sections of the DrawingTool API.
Click here to open the DrawingTool API
The top of an API tells you the import location (highlighted in yellow below).

The next section gives an overview of using the class. Always read this section first.

The Field Summary is a list of attributes (variables) the object keeps track of.
Attributes describe an object and keep track of its state. Typically, you don't have direct access to these variables. Instead, you modify them via methods that set and get their values.

The Constructor Summary is a list of the ways you can create and initialize objects of this class type.

The Method Summary is a list of the commands you can tell an object of this class type to do.

The rest of the API is the Constructor Detail and Method Detail. These sections are important because they give you critical information about the constructors and methods that is not covered in the summary. Shown below is the first constructor of the Constructor Detail.

Format of API methods
The general format is

modifiers - You'll learn more later but for now here's what matters:
Access modifiers affect who can access the method.
If a method is declared private, you cannot access or use it, and it won't usually appear in the API. Private methods are meant for behind-the-scenes code you don't need to care about when using the class.
If a method is declared as protected, it means that you can't use it unless you are writing a subclass of this API class.
If a method is declared as public, then the modifiers section will be blank which is what you see in the Method Summary above except for the protected drawLine method.
Non-access modifiers include static and abstract which you'll learn about later in this course. If you already have some Java experience and want to read about these click here.
return type - After the modifiers (which are often blank), you will always see a return type. The return type of a method tells you the kind of information the method sends back to you when the method finishes running its code.
A return type of void means the method does not send information back to the caller.
Otherwise, you will see a return type such as int, double, or perhaps an object type. You'll learn how to use return types in the next lesson.
Examples
Here are some examples from the DrawingTool API. In the examples below, assume we have already declared and initialized a DrawingTool object named bob.
- To use the forward method, we must pass in a double value that represents the distance to move in pixels. A double is a number that can be a decimal or integer.

bob.forward(50);  // Moves bob forward by 50 pixels  


To use the drawRect method, we must pass in two double values that represent the width and height of the rectangle. Also, if you read the method detail for drawRect, you'll find out that the rectangle will be centered around the DrawingTool's current location.

bob.drawRect(80, 200);  // Draws a rectangle 80 pixels wide by 200 pixels tall   


Some methods require objects in their parameters. For example, to use the setColor method we must first create a Color object and then pass it into the setColor method.

Color myColor;                   // Declare a Color object myColor = new Color(255, 0, 0);  // Create and initialize myColor to Red (discussed next page)     
bob.setColor(myColor);           // Change bob's drawing color, which affects future drawing  

Color class
Java comes with thousands of classes built-in. Every class in the java.lang package is automatically imported, so you don't have to write an import statement to use these classes. Two common classes you will be using from java.lang are:

Math class
String class
Representing Color
To change the DrawingTool's color, you will need to understand how colors are represented in programming languages. One of the most common representations is the RGB model.

As shown below, combining Red, Green, and Blue light creates white light (shown in the middle). It's like mixing paint, but with light instead of paint.



Every color visible to the human eye is simply an amount of red, green, and blue light. In programming languages, the amount of red, green, and blue ranges from 0 to 255. Experiment with this Color Picker and verify that:

Black is all colors set to 0
White is all colors set to 255
Yellow is a mixture of Red and Green
What ratio of colors creates Turquoise?
What ratio of colors creates Brown?
Colors in Java
Now that you understand RGB color components, you can use the Color class to create a Color and use it to change the DrawingTool's color.

Let's start with the code from the bottom of page F, earlier in this lesson. You should already have written this code by hand:

import gpdraw.DrawingTool;  // Import DrawingTool class  
import gpdraw.SketchPad;    // Import SketchPad class  

public class DrawSquare {  
      public static void main(String[] args) {  

        SketchPad paper;  // Declare a SketchPad variable DrawingTool pen;  // Declare a DrawingTool variable  
        paper = new SketchPad(400, 300);  // Create and initialize the paper 
        pen = new DrawingTool(paper);     // Create and initialize the pen  
        pen.setWidth(10);     // Change the pen width to 10  
        pen.forward(100);     // Draw left side, 100 pixels long 
        pen.turnRight(90); 
        pen.forward(100);     // Draw top 
        pen.turnRight(90); 
        pen.forward(100);     // Draw right 
        pen.turnRight(90); 
        pen.forward(100);     // Draw bottom 
    }  
}  

Open the Color API and read the class summary.

In order to use the Color class, you have to import it because it's not part of the default java.lang package.
On the previous page, you were told where to find the import location.
Use this knowledge to add an import statement for the Color class just below the SketchPad import statement.

Open the DrawingTool API and scroll down to the setColor method. Here's the summary:


This tells us that in order to use this method, we must create a Color object c and pass it into the setColor method. When calling the method, you don't have to name your Color variable 'c'. It can be anything.

Next, create a Color object using the second-to-last Constructor in the Constructor section. It looks like this:


Color myColor;                     // Declare a Color object named myColor  
myColor = new Color(127, 0, 127);  // Create and initialize myColor to purple  

You can also declare and create objects in one step:

Color myColor = new Color(127, 0, 127);  // Declare and create in one step  

Finally, use the DrawingTool's setColor method to set the color. (Put this before drawing.)

pen.setColor(myColor);

Program Comments
There are three kinds of program comments in Java.

// This is a single-line comment.
// Everything after the double slashes is ignored by Java.

/* This is a multi-line comment.
Everything between the slash stars is ignored by Java.
Note the reversal of slash-STAR then STAR-slash.
*/

/** This is a Javadoc comment.
Javadoc comments have additional formatting and are used to create APIs.
You will learn about them in Lesson 6.
*/
Why?
Comments are used to add clarity to programs.

It’s not obvious what this code does:

pen.up();
    pen.move(-1020Math.cos(Math.toRadians(60)), -150);
    pen.down();
 

    for (int i = 0; i < 10; i++) {
        pen.setDirection(90);
        pen.forward(100);
        pen.turnRight(30);
        pen.forward(20);
        pen.turnRight(120);
        pen.forward(20);
        pen.turnRight(30);
        pen.forward(100);
        pen.turnRight(90);
        pen.forward(220Math.cos(Math.toRadians(60)));
        pen.setDirection(0);
        pen.forward(220Math.cos(Math.toRadians(60)));
    }
    
Here is the same code but much easier to understand:

/* This program draws a row of 10 fenceposts by
using a for-loop to repeatly draw one post and
moving over to the next post location.
*/

    // Move the pen's starting location so the fence is centered horizontally
    pen.up();
    pen.move(-10*20*Math.cos(Math.toRadians(60)), -150);
    pen.down();

    // Draw 10 fenceposts by repeating one post 10 times
    for (int i = 0; i < 10; i++) {
        pen.setDirection(90);      // Left side
        pen.forward(100);
        pen.turnRight(30);         // Triangle top
        pen.forward(20);
        pen.turnRight(120);
        pen.forward(20);
        pen.turnRight(30);
        pen.forward(100);          // Right side
        pen.turnRight(90);

        // Base
        pen.forward(2*20*Math.cos(Math.toRadians(60)));
        pen.setDirection(0);

        // Move to next starting location
        pen.forward(2*20*Math.cos(Math.toRadians(60)));
    }
Remember:

Comment every program you write!

Compiling and Running a Program
Writing your program
Editors:
A programmer writes the text of a program using a software program called an editor.

Most editors, like BlueJ, are known as IDEs (Integrated Development Environments) because they also include tools to compile, run, and debug programs.
Source code
The text of a program in a particular programming language is referred to as source code. The source code is stored in a file called the source file.

For example, in the DrawSquare example given earlier, source code would be created and saved in a file named DrawSquare.java.
Compiling your program
Compiling is the process of converting a program written in a high-level language into the bytecode language the Java interpreter understands.

A Java compiler will generate a bytecode file from a source file if there are no errors in the source file.

In the case of DrawSquare, the source statements in the DrawSquare.java source file would be compiled to generate the bytecode file DrawSquare.class.
Classes inside a package, such as gpdraw.jar, have already been compiled into bytecode for you.


Figure 1.5 - From Source Code to Running Program

Errors:
Errors detected by the compiler are called compilation errors.

Compilation errors are actually the easiest type of errors to correct.

Most compilation errors are due to the violation of syntax rules.
These are the basic rules of languages that programmers must follow so that the interpreter understands what to do. It is similar to grammar in a spoken language and varies from language to language.
If an error occurs while running the program (meaning it compiled successfully), the interpreter will catch it and stop its execution. Errors detected by the interpreter are called run-time errors.

Run-time errors are usually caused by a fault in the logic of the program, such as accidentally causing the computer to try and divide a number by zero.

Edit-Compile-Run Cycle for a Java Program

Things to know when you write your first program
One class per file

Although it's technically possible to have multiple classes in a single file, for now please have one class per file. You may have problems otherwise.
Java is case-sensitive

DrawSquare is not the same as Drawsquare. Upper and lowercase are different identifiers to Java.
File and class name must match

If your class name doesn't match the file name exactly (but without the .java extension), your code won't compile. For example, DrawSquare.java should contain class DrawSquare.
Spaces are not allowed in class names and variable names.

Additionally, you cannot begin a class or variable name with a numerical value. You can have numbers after the first letter, however. Some special characters such as underscores are allowed but not conventionally used. This isn't C programming.
Braces matter for compiling

Make sure every opening brace has a matching closing brace { }
Indenting matters for readability

The contents inside every pair of braces { } should be indented one tab.
"gpdraw.*" cannot be found

If you get this error then you didn't correctly follow steps 4 and 5 on the Java Setups Lesson. It's also possible that you downloaded gpdraw.jar incorrectly. When downloading gpdraw.jar some web browsers try to change the filename to gpdraw.zip. Don't allow that. Change it back to gpdraw.jar.
Selective debugging

If you have an error but don't know what line it's on (BlueJ doesn't always tell you the correct line number) then a very good debugging technique is to comment out all of the individual instruction lines (any line ending in a semicolon) and look at the overall structure. If you still have compiling problems then you're missing a brace somewhere. Otherwise, you can start uncommenting the instruction lines one by one until you find the problem.


Lesson 2: 
Class Structure
Ignoring special cases, all classes have three sections:

Attributes - Variables that describe objects of this class
Constructors - Methods with the same name as the class used to initialize objects of this class
Methods - Code that defines the actions an object of this class type can perform
In order to distinguish classes from objects, class names should always begin with a capital letter. Objects should always begin with a lowercase letter.



Here is the general structure for a class:

public class MyClass {

    // Attributes

    // Constructors

    // Methods
}

Attributes
Our goal is to create a Window class that can be used to create many different window objects from the same blueprint.

public class Window {

    // Attributes

    // Constructors

    // Methods
}

Consider the window shown below:



What attributes describe this window? Here are some possibilities:

x-position
y-position
width
height
interior color
frame color
line thickness
number of panels
If we want to add these attributes to our Window class, we need to declare them as variables that can store the right kind of information. Here are the data types you will need for now. See Lesson 3 for a complete list.

Data type	What it represents	Examples
int	an integer	int x = 5; int y = -108;
double	a floating-point number	double pi = 3.14; double z = -1000; double w = 0.0001; Note that a double can also hold an integer.
some class	an object of that class	DrawingTool pen; SketchPad pad; Color c; String str;

Let's use these data types to add some attributes to our Window class.

public class Window {

    // Attributes
    int xPos;
    int yPos;
    int width;
    int height;
    Color frameColor;
    Color interiorColor;

    // Constructors

    // Methods
}

Constructors
A constructor is a method with the same name as the class. Constructors are used during object creation to initialize the starting state of an object.

So far you have used constructors to create objects of type SketchPad, DrawingTool, and Color. For example, in order to create a SketchPad object you would use a SketchPad constructor:



Although you have used constructors, you have not written blueprint code for them yet - which is what we're about to do. The format of a constructor is:

public class ClassName {

    // Attributes

    // Constructors public ClassName(param1, param2, param3, …) {
        Use the constructor parameters to initialize some of the attributes
        Initialize the remaining attributes by assigning default values.
    }

    // Methods
}

The parameter list of a constructor is usually a list of attributes you want users of your class to pass in when creating objects of the given class. Start with a short list of essential parameters. For example,

public class Window {

    // Attributes
    int xPos;
    int yPos;
    int width;
    int height;
    Color frameColor;
    Color interiorColor;

    // Constructors public Window(int x, int y) {
        // Use the constructor parameters x and y to initialize the xPos and yPos attributes
        xPos = x;
        yPos = y;

        // Choose default values for the rest of the attributes
        width = 100;
        height = 100;
        frameColor = Color.GRAY;
        interiorColor = new Color(255, 255, 0);
    }

    // Methods
}

You can have as many constructors as you want as long as they have a different set of parameter data types. The constructor shown above had parameters if type (int, int). Therefore, you wouldn't be allowed to have another constructor that has exactly two int parameters, but you could have one that has two ints and a Color as shown below.

public class Window {

    // Attributes
    int xPos;
    int yPos;
    int width;
    int height;
    Color frameColor;
    Color interiorColor;

    // Constructors
    public Window(int x, int y) {
        // Use the constructor parameters x and y to initialize the xPos and yPos attributes
        xPos = x;
        yPos = y;

        // Choose default values for the remaining attributes
        width = 100;
        height = 100;
        frameColor = Color.GRAY;
        interiorColor = new Color(255, 255, 0);
    }
     public Window(int x, int y, Color fColor) {

        // Use the constructor parameters to initialize user-chosen attributes
        xPos = x;
        yPos = y;
        frameColor = fColor;

        // Choose default values for the remaining attributes
        width = 100
        height = 100
        interiorColor = new Color(255, 255, 0);
    }

    // Methods
}

At some point, it's not convenient to have a long list of parameters for every possible attribute in your class. For example,

public Window(int x, int y, int, int w, int h, Color fColor, Color iColor) {
        ...
}

Instead of long constructor parameter lists, you should add helper methods to let users of your class change the values of each kind of attribute. This is discussed in the next pages.

Methods
A method is an action that an object can perform. So far, you have used methods but not created them yourself. Now it's time to create methods.

Unlike constructors, methods must include a return type. A return type is the kind of information a method sends back to the caller of the method. You can think of this like a function in mathematics. If we define function f(x) = 2*x then calling f(5) returns 10. 10 is the returned value and its return type is an integer.

In Java, function f(x) would be written as a method with an int return type:



To call this method outside its class you would write something like bob.f(5); where bob is an object of the class type that f(x) is defined in. We will discuss how to use methods with return values in Lesson 4.

Methods that do not return a value have a return type of void. This is the kind of method you need for your house project.

Let's add a draw() method to our Window class:

public class Window {

    // Attributes
    ...same as before

    // Constructors
    ...same as before

    // Methods 
    public void draw() {
        pen.up();                   // Move to window location
        pen.move(-200, 0);
        pen.setDirection(90);
        pen.down();

        pen.drawRect(100, 100);     // Draw the window
        pen.forward(50);
        pen.backward(100);
        pen.forward(50);
        pen.turnRight(90);
        pen.forward(50);
        pen.backward(100);
    }
}

There are two problems with the code above. - There is no pen object defined so nothing can be drawn - The drawing is hard-coded, meaning that its position, size, and colors are fixed rather than dependent upon the attribute values. To solve the issue of not having a pen object, we could try to create a new SketchPad and DrawingTool:
public void draw() {
    Sketchpad pad = new SketchPad(800, 600):
    DrawingTool pen = new DrawingTool(pad); 
    pen.up();                   // Move to window location
    pen.move(-200, 0);
    pen.setDirection(90);
    pen.down();

    pen.drawRect(100, 100);     // Draw the window
    pen.forward(50);
    pen.backward(100);
    pen.forward(50);
    pen.turnRight(90);
    pen.forward(50);
    pen.backward(100);
}

Unfortunately, this won't work because every time we call the draw() function, the window object will be drawn in a new SketchPad. Instead of this:
We'll get this:



A correct approach would be to add a DrawingTool attribute to the Window class and allow the user of our Window class to specify which SketchPad to draw in through the constructor:

public class Window {

    // Attributes
    .. same as before DrawingTool pencil;

    // Constructors
    public Window(int x, int y, SketchPad pad) {
        // Use the constructor parameters x and y to initialize the xPos and yPos attributes
        xPos = x;
        yPos = y;

        // Use the constructor parameter pad to initialize the pencil to DrawingTool that draws in that pad
        pencil = new DrawingTool(pad);

        ...same as before
    ...
}  

Now we have a working Window class.

public class Window {

    // Attributes
    int xPos;
    int yPos;
    int width;
    int height;
    Color frameColor;
    Color interiorColor;
    DrawingTool pencil;

    // Constructors
    public Window(int x, int y, SketchPad pad) {

        // Use the constructor parameters to initialize the xPos, yPos, and pencil attributes
        xPos = x;
        yPos = y;
        pencil = new DrawingTool(pad);

        // Choose default values for the rest of the attributes
        width = 100;
        height = 100;
        frameColor = Color.BLACK;
        interiorColor = new Color(255, 255, 0);
    }

    // Methods   
    public void draw() {
        pencil.up();                   // Move to window location
        pencil.move(-200, 0);
        pencil.setDirection(90);
        pencil.down();

        pencil.drawRect(100, 100);     // Draw the window
        pencil.forward(50);
        pencil.backward(100);
        pencil.forward(50);
        pencil.turnRight(90);
        pencil.forward(50);
        pencil.backward(100);
    }
}

Because we have hard-coded the window values, Window objects will always be centered at (-200, 0) with a width and height of 100. Let's replace the hard-coded values with our attributes so that Window objects are based on the attribute values.

public class Window {

    // Attributes
    int xPos;
    int yPos;
    int width;
    int height;
    Color frameColor;
    Color interiorColor;
    DrawingTool pencil;

    // Constructors
    public Window(int x, int y, SketchPad pad) {

        // Use the constructor parameters to initialize the xPos, yPos, and pencil attributes
        xPos = x;
        yPos = y;
        pencil = new DrawingTool(pad);

        // Choose default values for the rest of the attributes
        width = 100;
        height = 100;
        frameColor = Color.BLACK;
        interiorColor = new Color(255, 255, 0);
    }

    // Methods   
    public void draw() {
        pencil.up();                // Move to window location
        pencil.move(xPos, yPos);
        pencil.setDirection(90);
        pencil.down();
         pencil.setColor(interiorColor);        // Change color before drawing interior of window
        pencil.fillRect(width, height);     // Draw interior of window
        pencil.setColor(frameColor);        // Change color before drawing outer frame of window 
        pencil.drawRect(width, height);     // Draw the window
        pencil.forward(height/2);
        pencil.backward(height);
        pencil.forward(height/2);
        pencil.turnRight(90);
        pencil.forward(width/2);
        pencil.backward(width);
    }
}

Setter Methods
Instead of long constructor parameter lists, you should consider writing helper methods to let users of your class change the values of attributes. A helper method that modifies the value of an attribute is called a setter method.

First, let's add a setter method to allow Window objects to change their dimensions:

public void setDimensions(int w, int h) {
    width = w;   // Update attributes with new values passed in
    height = h;
}

Let's also add a setter method to allow Window objects to change their frame color:

public void setFrameColor(Color c) {
    frameColor = c;
}

You should write as many setter methods as it takes to cover all the attributes.

The Difference Between Objects and Classes
An object is very closely associated with the class to which it belongs. An object has attributes as defined by its class. An object’s behavior is restricted by the methods that are included in its class. However, there are significant differences between objects and classes.

A class:
is a blueprint that defines attributes and methods.
cannot be altered during the program's runtime.
should begin with a capital letter.
An object:
is an instance of a certain class. (This is the most critical piece.)
exists during a program's runtime only.
must be explicitly declared and constructed within a program.
has attributes that can change in value and methods that can execute during program execution.
is referenced using an identifier, which should begin with a lowercase letter.
In a nutshell, classes are the blueprints for objects. Each class, or blueprint, is designed to produce many objects, all of a single type.

On the other hand, each object belongs to a single class. The myPencil object that was created earlier belongs to the DrawingTool class; myPencil, therefore, is the same type as all other objects created from DrawingTool, and can perform all of the methods a DrawingTool can. On that front, it cannot call methods from or hold attributes defined in the Math class, for obvious reasons.

Javadocs
Now that we have created a Window class, we should create an API for our class to tell users of our class how to use it.

The JDK comes with a tool called Javadoc that can create APIs from any Java class that is commented using a specific format. That format is known as Javadoc comments, or Doc comments. We will study this format in more detail in a future lesson, but for now here's the format you need to use:

/**
    This is a Javadoc comment.  The text you write here will be displayed as the summary text
    for whatever element (class header, method header, attribute) directly follows this comment.

    If what follows this comment is a void method or constructor then you also need to supply
    a description for each parameter in the format shown below:

    @param param1_name Description
    @param param2_name Description
    @param param3_name Description
    ...
*/

The first Javadoc comment you should write is a class summary that describes the purpose and usage of your class. Since Javadoc comments always describe whatever element is directly below them, you should put this summary comment immediately above the class declaration.

After the class summary, you should write a Javadoc comment above each attribute explaining its purpose.

After commenting the attributes, you should write a Javadoc comment above each constructor you have.

Finally, write a Javadoc comment above each method. If the method has parameters, include an @param tag for each parameter as shown in the second method below.

Adding line breaks

Since a Javadoc API is an HTML web page, all whitespace is ignored. This means that any attempt at line breaks and whitespace formatting is ignored.

If you type the following, instead of seeing what you might expect:

You will actually see this block of text:

In order to hardcode a line break (enter key), you can use the HTML tag <br> in your Javadoc comment. For example, if this is your Javadoc comment:

A second or alternate solution is to use the HTML preformatted tag <PRE> </PRE> which displays everything between the tags in a monspaced font EXACTLY as you wrote it.

Identifiers in Java
An identifier is a name that will be used to describe classes, methods, constants, variables; anything a programmer is required to define.

The rules for naming identifiers in Java are:

Identifiers must begin with a letter.
Only letters, digits, or an underscore may follow the initial letter.
The blank space cannot be used.
Identifiers cannot be reserved words. Reserved words or keywords are already defined in Java. These include words such as new, class, int, etc. See Handout A3.1, Reserved Words in Java
Java is a case-sensitive language. That is, Java will distinguish between upper and lower case letters in identifiers. Therefore: grade and Grade are different identifiers

Be careful both when naming identifiers and when typing them into the code. Be consistent and don’t use both upper and lower case names for the same identifier.

A good identifier should help describe the nature or purpose of whatever it is naming. For a variable name, it is better to use grade instead of g, number instead of n.

However, avoid excessively long or "cute" identifiers such as: - gradePointAverageForStudentsAToZ
- or bigHugeUglyNumberThatIsPrettyPointlessButINeedItAnyway

Remember that the goal is to write code that is professional in nature; other programmers need to understand your code.

Programmers will adopt different styles of using upper and lower case letters in writing identifiers. The reserved keywords in Java must be typed in lower case text, but identifiers can be typed using any combination of upper and lower case letters.

The following conventions will be used throughout this curriculum guide:

A single word identifier will be written in lower case only. Examples: grade, number, sum.
Class names will begin with upper case. Examples: String, DrawingTool, SketchPad, Benzene.
If an identifier is made up of several words, all words beyond the first will begin with upper case. Examples: stringType, passingScore, largestNum, DrawHouse, SketchPad.
Identifiers used as constants will be fully capitalized. Examples: PI, MAXSTRLEN.


Primitive Data Types in Java
Java provides eight primitive data types: byte, short, int, long, float, double, char, and boolean. The data types byte, short, int, and long are for integers, and the data types float and double are for real numbers (numbers with decimal places).

The College Board Advanced Placement (AP) Examinations only require you to know about the int, double, and boolean data types. This curriculum will, from time to time, also use the char type when appropriate.

An integer is any positive or negative number without a decimal point.

Examples: 7 -2 0 2025
A double is any signed or unsigned number with a decimal point. Doubles cannot contain a comma or any symbols. A double value can be written using scientific notation.

Valid numbers: 7.5 -66.72 0.125 5
Invalid numbers: $37,582.00 #5.0 10.72%
Scientific notation: 1625. = 1.625e3 .00125 = 1.25e-4
Note: When applying 5 to a double variable, Java will automatically add the decimal point for you.

The following table summarizes the bytes allocated and the resulting size.

Name	Size	Minimum Value	Maximum Value
byte	1 byte	-128	127
short	2 bytes	-32768	32767
int	4 bytes	-2147483648	2147483647
long	8 bytes	-9223372036854775808	9223372036854775807
float	4 bytes	-3.40282347E+38	3.40282347E+38
double	8 bytes	-1.79769313486231570E+308	1.79769313486231570E+308

Character type consists of letters, digits 0 through 9, and punctuation symbols. A character must be enclosed within single quotes.

Examples: 'A', 'a', '8', '*'
Java characters are stored using 2 bytes according to the ASCII code. ASCII stands for American Standard Code for Information Interchange. See Handout A3.2, ASCII Characters - A Partial List

Using ASCII, the character value 'A' is actually stored as the integer value 65. Because a capital 'A' and the integer 65 are physically stored in the same fashion, this will allow us to easily convert from character to integer types, and vice versa.




In Java, you can make a direct assignment of a character value to an integer variable, and vice versa. This is possible because both an integer and a character variable are ultimately stored in binary. However, it is better to be more explicit about such conversions by using type conversions. For example, the two lines of code below assign to position the ASCII value of letter.



Programmers use the single quote to represent char data and double quotes to denote String types. To use either of those characters in a String literal, such as in a System.out.println statement, you must use an escape sequence. Java provides escape sequences for unusual keystrokes on the keyboard. Here is a partial list:

Character	Java Escape Sequence
Newline	'\n'
Horizontal tab	'\t'
Backslash	'\\'
Single quote	'\''
Double quote	'\"'
Null character	'\0'




Data types are provided by high-level languages to minimize memory usage and processing time. Integers and characters require less memory and are easier to process. Floating-point values require more memory and time to process.

The last primitive data type is the type boolean. It is used to represent a single *true/ false value,* and it can only hold one of these two values.

In a Java program, the reserved words true and false always refer to these boolean values.

Declaring and Initializing Variables in Java
A variable must be declared before it can be initialized with a value. The general syntax of variable declarations is:

data_type variableName;
For example:

int number;
char ch;
Variables can be declared in a class outside of any methods or inside of a method. Variables can also be declared and initialized in one line. The following example code illustrates these aspects of variable declaration and initialization.



Code Sample 3-1

Note that multiple variables can be declared on one line. Initialization is done using the assignment operator (=). Initialization can occur at declaration time or later in the program. The variable sum was declared and used in the same line.

Where variables are declared is a matter of programming style and need since this determines how and where they can be used.

Printing Variables Using the System.out Object
The System.out object is automatically created in every Java program. It has methods for displaying text strings and numbers in plain text format on the system display, which is sometimes referred to as the “console.” For example:



Code Sample 3-2

Method System.out.println displays (or prints) a line of text in the console window. When System.out.println completes its task, it automatically positions the output cursor (the location where the next character will be displayed) to the beginning of the next line in the console window (this is similar to pressing the Enter key when typing in a text editor-the cursor is repositioned at the beginning of the next line).

The expression

"number = " + number

from the statement

System.out.println("number = " + number);

uses the + operator to “add” a string (the literal "number = ") and number (the int variable containing the number 5). Java defines a version of the + operator for String concatenation that enables a string and a value of another data type to be concatenated (added). The result of this operation is a new (and normally longer) String. String concatenation is discussed in more detail later on.

The lines

System.out.print("The ");
System.out.println("End!");

of Code Sample 3-2 display one line in the console window. The first statement uses System.out’s method, print, to display a string. Unlike println, print does not position the output cursor at the beginning of the next line in the console window after displaying its argument. The next character displayed in the console window appears immediately after the last character displayed with print.

Note the distinction between sending a String literal, "number = ", versus a variable, number, to the System.out object. A boolean variable will be printed as true or false.

The result (or output) of formulas using Strings may also be printed. Note how the placement of the quotes affects the output.

Assignment Statements
An assignment statement has the following basic syntax:

variable = expression;

The assignment operator (=) assigns the value of the expression on the right to the variable.

a = 5;

This is not the same as saying, “a equals five,” but is more akin to, “a receives the value five.”

The expression can be a literal constant value such as 2, 12.25, 't' or it can also be a numeric expression involving operands (variables or constants) and operators.

a = 5 + 2; b = 6 * a;

The assignment operator returns the value of the expression. Returning values in this way allows for chaining of assignment operators. Chaining is when you have more than one assignment in a statement as shown below.

a = b = 5;

The assignment operator is right-associative. This means that the above statement is really solved in this order:

a = (b = 5);// solved from right to left.

Since (b = 5) returns the integer 5, the value 5 is also assigned to variable a.

Variables contain either primitive data or object references. Notice that there is a difference between the two statements:

primitiveValue = 18234;

and

myPencil = new DrawingTool();

A variable will never actually contain an object, only a reference to an object. In the first statement, primitiveValue is a primitive type, so the assignment statement puts the data directly into it. In the second statement, myPencil is an object reference variable (the only other possibility) so a reference to the object is put into that variable. The object reference tells the program where to find an object.

Variable Type	Information It Contains	When On the Left of "="
primitive	Contains actual data	Previous data is replaced with new data
Object	Contains a reference, i.e. information on how to find the object referred to by the variable	Old reference is replaced with a new reference

The two types of variables are distinguished by how they are declared. Unless it was declared to be of a primitive type, it is an object reference variable. A variable will not change its declared type.

Be aware. Because these assignments work differently with primitive data types and with objects, you may experience unexpected behavior. Consider the following:



In this example, pencil will draw a blue line instead of red. In fact, we have only created one object here! When we say DrawingTool pen = pencil, all we are doing is assigning the variable name of ‘pen’ to the same object that pencil is already assigned to. This means pen and pencil refer to the same thing, so anything you do to either one happens to the other one!

Math Operators
Java provides 5 math operators as listed below:

+ Addition, as well as unary +
- Subtraction, as well as unary -
* Multiplication
/ Floating point and integer division
% Modulus, remainder of integer or floating point division
The numerical result and data type of the answer depends on the type of operands used in a problem.

For all the operators, if both operands are integers, the result is an integer. Examples:

2 + 3 -> 5
9 - 3 -> 6
4 * 8 -> 32
11/2 -> 5
Notice that 11/2 is 5, and not 5.5. This is because ints work only with whole numbers. The remaining half is lost in integer division.

If either of the operands is a double type, the result is a double type. Examples:

2 + 3.000 -> 5.000
25 / 6.75 -> 3.7037
11.0 / 2.0 -> 5.5
When an integer and a double are used in a binary math expression, the integer is promoted to a double value, and then the math is executed. In the example 2 + 3.000 -> 5.000, the integer value 2 is promoted to a double (2.000) and then added to the 3.000.

The modulus operator (%) returns the remainder of dividing the first operand by the second. For example:

10 % 3 -> 1
2 % 4 -> 2
16 % 2 -> 0
27.475 % 7.22 -> 5.815
Changing the sign of a value can be accomplished with the negation operator (-), often called the unary (-) operator. A unary operator works with only one value. Applying the negation operator to an integer returns an integer, while applying it to a double returns a double value. For example:

-(67) -> -67
-(-2.345) -> 2.345
To obtain the answer of 5.5 to a question like 11/2, we must cast one of the operands.

(double)11/2 results in 5.5
The casting operators are unary operators with the following syntax:

(type) operand
The same effect can also result from simply

11.0/2

Precedence of Math Operators
Precedence governs the order in which an expression is solved. For example:

2 + 3 * 6 -> 20 the * operator has priority over +.
Associativity refers to the order in which operators are applied if they have the same precedence level. The two possibilities are from left-to-right or right-to-left.

A unary operator is used on only one number. An example of a unary operator is the negative sign in the expression -a, meaning the negative of a.

The following table summarizes precedence and associativity of math operators:

Level of Precedence	Operator	Associativity
Highest	unary -	right to left
* / %	left to right
Lowest	+ -	left to right

An example follows:

9 + 16 / 3 * 7 % 8 - 5 (solve / first)

9 + 5 * 7 % 8 - 5 (solve * second)

9 + 35 % 8 - 5 (solve % next)

9 + 3 - 5 (solve left-to-right)

7

Parentheses take priority over all the math operators.

(5+6)/(9-7) -> 11/2 -> 5 (integer division, which drops remainders, is used here)

Assignment Operators
The statement number = number + 5; is an example of an accumulation statement. The old value of number is incremented by 5 and the new value is stored in number.

The above statement can be replaced as follows:

number += 5;

Java provides the following assignment operators:

+= -= *= /= %=

These statements are preferable to saying number = number + 5 because they are more convenient and easier to read. You can immediately tell at a glance exactly what is being done.

The following examples are equivalent statements:

rate *= 1.05; rate = rate * 1.05;

sum += 25; sum = sum + 25;

number %= 5; number = number % 5;

The precedence of the assignment operators is the lowest of all operators.

Increment and Decrement Operators
Incrementing or decrementing by one is a common task in programs. This task can be accomplished by the statements:

n = n + 1; or n += 1;

Java also provides a unary operator called an increment operator, ++.

The statement n = n + 1 can be rewritten as ++n. The following statements are equivalent:

n = n + 1; ++n;

sum = sum + 1; ++sum;

Java also provides for a decrement operator, --, which decrements a value by one. The following are equivalent statements:

n = n - 1; --n;

sum = sum - 1; --sum;

The increment and decrement operators can be written as either a prefix or postfix unary operator. If the ++ is placed before the variable it is called a pre-increment operator (++number), but it can follow after the variable (number++), which is called a post-increment operator. The following three statements have the same effect:

++number; number++; number = number + 1;

Before looking at the difference between prefix and postfix unary operators, it is important to remember Java operators solve problems and often return values. Just as the assignment operator (=) returns a value, the ++ and -- operators return values. Consider the following code fragments:



The statement b = ++a uses the pre-increment operator. It increments the value of a and returns the new value of a.

The statement b = a++ uses the post-increment operator. It returns the value of a and then increments a by 1.

The precedence and associativity of the unary increment and decrement operators is the same as the unary - operator.

Writing Methods in Java
Methods are what an object can actually do, such as in our DrawingTool example:

myPencil.forward(100);
myPencil.turnLeft();

We wrote our own methods (DrawSquare, draw) and we used some methods from the DrawingTool class (forward, turnLeft).

Parameters and Arguments
Parameters and arguments are used to pass information to a method. Parameters are used when defining a method, and arguments are used when calling the method.

Examine this sample code:

DrawingTool myPencil = new DrawingTool();
myPencil.turnLeft(60);
myPencil.forward(100);
In the above code, we use the DrawingTool’s turnLeft(double) method to turn the myPencil object by a given degrees counterclockwise. Since we wrote 60 inside the parentheses, the argument we are passing is 60.

If we don’t pass an argument, then we are calling the turnLeft() method, which is considered a different method by the Java compiler. That method turns the drawing tool 90 degrees counterclockwise. Since there are two methods named turnLeft, you would say that turnLeft is overloaded. The compiler knows which one we are trying to call by matching the types of the arguments to the parameter types in the method signature. We passed an int, so first it would look for a turnLeft(int), but that does not exist, so it would see that there is a turnLeft(double) and our int argument can be automatically converted to a double, so turnLeft(60) is compatible with the method turnLeft(double).

When defining a method, the list of parameters can contain multiple parameters. For example:



When this method is called, the arguments fed to the doMath method must be the correct type and must be in the same order. The first argument must be an int. The second argument can be a double or an int (since an int will automatically be converted by Java).



Arguments can be either literal values (2, 3.5) or variables (a, x).



Primitive vs Object parameters
When a method is called with an argument, the parameter receives the value of the argument. The value will always be a number, but the number can be interpreted differently depending on the type of the variable.

If the data type of the parameter is a primitive type, the value of the variable will be interpreted directly as a number, character or boolean value.
If the data type of the parameter is a class, then the parameter variable is a reference variable, which means its value is interpreted as the address of an object in memory. This means that anything the method does to that parameter will be done to the object at the address we passed in as our argument.
Here is an example:

import java.awt.Point;
    public class ParamDemo {
        public static void main(String[] args) {
            int x = 3;
            Point mp = new Point(x, 1);
            changeX(mp, x);
            System.out.println(mp.x);
        }
 

        public static void changeX(Point p, int x) {
            x = x + 2;
            p.x = x;
        }
    }
    
Analysis:

First we will draw a diagram showing what happens in memory at runtime. In order to do this, first we need to discuss two sections of memory: the stack and the heap.

The stack is a place in memory where method calls are stored. Each method gets assigned its own section of the stack where all of the local variables used in that method are stored (including parameter variables).

The heap stores all the objects created during program execution, regardless of which method they were created in. Each object is stored at a memory address which we will label in our diagrams with an @ symbol followed by a number. For example, @67 means memory address 67.

Thus, the value of a variable whose type is a class will be a memory address like @67. For primitive values, since they store a value directly, we will simply write the numeric value stored.

When changeX is first called in the the main method, the stack and heap look like this:

Stack                                 Heap
main(@34) 
    args = @34                 String[] {} @34
    x = 3
    mp = @23                   Point (3, 1) @23

changeX(@23, 3)
    p = @23
    x = 3
Notice that the p variable in the changeX method, stores the same memory address (@23) as the mp variable from the main method. This means, mp and p both reference the same object. You might also notice that there is a local variable in the main method named x that has value 3 and a local variable named x in changeX that is also 3. Those are two different local variables that happen to have the same name. The value of the x in the main method (3) was passed in as an argument to the changeX method and the value of the x parameter in changeX was assigned that value (3).

After the first line of code in changeX x = x + 2, the value of the x variable in the changeX method is changed from 3 to 5, so the stack and heap would look like this:

Stack                                 Heap
main(@34) 
    args = @34                 String[] {} @34
    x = 3
    mp = @23                   Point (3, 1) @23

changeX(@23, 3)
    p = @23
    x = 5
Notice that the x variable in the main method is unaffected by changing the value of the x variable in changeX. They are two different variables, so changing one has no affect on the other.

Next, the line p.x = x is executed. This means, go to the object referenced by p (the Point object at memory address @23), and change the value of its x attribute to the value of the local x variable (5). The stack and heap would now look like this:

Stack                                 Heap
main(@34) 
    args = @34                 String[] {} @34
    x = 3
    mp = @23                   Point (5, 1) @23

changeX(@23, 3)
    p = @23
    x = 5
Notice, since the Point object at address @23 was changed, that change will still be in effect when accessed through the mp variable in the main method.

The changeX method is now finished, so it is removed from the stack and the stack and heap would look like this:

Stack                                 Heap
main(@34) 
    args = @34                 String[] {} @34
    x = 3
    mp = @23                   Point (5, 1) @23
In the main method, the next line of code executes System.out.println(mp.x) which prints the value of the x attribute of the Point object referenced by mp (at memory address @23), which would print 5.

Returning Values
Sometimes we want a method to return a value.

In order for a method to return a value, there must be a return statement somewhere in the body of the method.

You must also declare which type of data value will be returned in the method declaration. This can be any primitive data type, a Java class, or any class that you have defined yourself.



If a method returns no value, the keyword void should be used.

The Signature of a Method
In order to call a method legally, you need to know its name, how many parameters it has, the type of each parameter, and the order of those parameters.

This information is called the method’s signature.

Signatures in action
The signature of the method doMath can be expressed as:

doMath(int, double)

Note that the signature does not include the names of the parameters. If you just want to use the method, you don't need to know what the parameter names are, so the names are not part of the signature.

Method overloading
Java allows two different methods in the same class to have the same name, provided that their signatures are different. This is called overloading a method.

We say that a method's name is overloaded when one name has multiple different meanings. The Java compiler doesn't get the methods mixed up because their signatures are distinct. A basic example is println. All of these methods have different signatures, but the same name:

println(int)

println(double)

println(String)

println(char)

println(boolean)

println()

In addition to these, we have been using this concept with the DrawingTool class and its turnLeft method.

turnLeft()
turnLeft(120)
It is illegal to have two methods in the same class that have the same signature but have different return types. For example, it would be a syntax error for a class to contain two methods defined as:

double doMath(int a, double x){// some code}
int doMath(int b, double y){// some code}
The Java compiler cannot differentiate return values, so it uses the signature to decide which method to call.

Lifetime, Initialization, and Scope of Variables
Three categories of Java variables have been explained thus far in these lessons.

Instance variables
Local variables
Parameters
Variable lifetime
The lifetime of a variable defines the portion of runtime during which the variable exists.

When an object is constructed, all its instance variables are created. As long as any part of the program can access the object, it stays alive.
A local variable is created when the program executes the statement that defines it. It stays alive until the block that encloses the variable definition is exited.
When a method is called, its parameters are created. They stay alive until the method returns to the caller.
Variable initialization
The type of the variable determines its initial state.

Instance variables are automatically initialized with a default value (0 for numbers, false for boolean, null for objects).
Parameters are initialized with copies of the arguments.
Local variables are not initialized by default so an initial value must be supplied. The compiler will generate an error if an attempt is made to use a local variable that may not have been initialized.
Scope
Scope refers to the area of a program in which an identifier is valid and has meaning.

Instance variables are usually declared private and have class scope. Class scope begins at the opening left brace ({) of the class definition and terminates at the closing brace (}). Class scope enables methods to directly access all of its instance variables.
The scope of a local variable extends from the point of its definition to the end of the enclosing block.
The scope of a parameter is the entire body of its method.
An example of the scope of a variable is given in Code Sample 4-2. The class ScopeTest is created with three methods:



Code Sample 4-2

The results show the following about the scope of the variable test:

Within the scope of main, the value of test is 10, the value assigned within the main method.
Within the scope of printLocalTest, the value of test is 20, the value assigned within the printLocalTest method
Within the scope of printClassTest, the value of test is 30, the private value assigned within ScopeTest, because there is no value given to test within the printClassTest method
Within the scope of printParamTest, the value of test is 40, the value sent to the printParamTest method

Getters and Setters
When you are first starting to program, some of the most commonly used methods are called Getters and Setters (some like to call them Mutators and Accessors). These methods deal directly with attributes of the object they are associated with.

Why getters?
When we are working with an object, sometimes we will need to know certain pieces of information about the object that only the object can tell us reliably.

Recall the DrawSquare class that we worked with earlier. We might remember the length of a side, but if that length has changed for some reason during the life of the object, we might be in for a surprise if we used that value.

Here we would want to store the side length in a private instance variable sideLength and provide a Getter method along the lines of double getSideLength(). The Getter method’s purpose would be to give us current information about that object.
We don’t want to let other objects access the side length directly, because they might alter that data when we don’t want them to. The getSideLength method allows other objects to look at the data in our DrawSquare object and storing the length in a private variable prevents these objects from directly accessing the length.
What about setters?
What happens if we do want to change that side length from outside our class?

As it stands right now, that would not be possible.

However, we could create a Setter method in the DrawSquare class that would do this for us, void setSideLength(double d). This method’s basic purpose is to change the value of the sides for us, but it could also do a bit more.
For instance, what if someone passed setSideLength a value of negative 10? Our square could obviously not exist with a negative side value, so our Setter program should check for validity of the values. Setters can often do calculations for us when necessary, so they are not always simply changing a value and doing nothing else.
Often, Setter methods are given a return type of boolean which will return true if the value was valid and false if the value was not. This lets clients know if their value was accepted or not. If the client sends an invalid value to a method, it is usually good for them to know that they tried to use the method incorrectly.

Access Modifiers
Some of the fields, methods, and classes we've used are declared with a public keyword in front.

What does public do? Why do we need it? Are there alternatives to public?

The Public Modifier
By adding a public keyword in front, we are declaring that a particular variable, method, or class can be accessed by any other class in any package.

The Package-Private Modifier (No Modifier)
By adding nothing in front, we are declaring that a particular variable, method, or class can be accessed by any other class within the same package,

This means if someone else is importing your code from another package, they can only access the methods, fields and constructors declared with the public access modifier.

The Private Modifier
By adding a private keyword in front, we are declaring that a particular variable, method, or class can only be accessed within the same class. When writing a class, in most cases you should declare fields private and create getters and setters to access and modify them. This gives you the opportunity to protect your class from being broken when a field is set to an invalid value and even gives you the option to only declare a getter, making the field effectively read-only.

The Protected Modifier
The protected access modifier indicates that a field or method can be accessed within the same class, within subclasses of the class or within classes in the same package, but cannot be accessed by any other classes. This keyword is typically used when you want subclasses to still be able to directly use or modify a method or field that is otherwise only supposed to be accessed internally or through getters and setters. Using the protected method also allows classes to declare methods that are meant to be overridden in subclasses, but are not meant to be called by code that is just using the class. We will discuss this more when we discuss inheritance.

Designing a Class
One of the advantages of object-oriented design is that it allows a programmer to create a new data type that is reusable in other situations.

When designing a new class, three components must be identified — attributes, behaviors, and constructors. To determine attributes of a class, look at the nouns associated with that object. To determine behaviors, look at the verbs.

Real-world connections
Let’s consider a checking account at a bank.

The account would need to record such things as:

the account number
the current balance
the type of checking account it is, etc (these are nouns).
These would be the attributes of the checking account.

It would also need to be able to do certain actions, such as:

withdrawing
depositing money (these are verbs).
These would be the behaviors of the checking account.

Finally, the checking account object needs to be created in order to be used, so the class must define how the creation process works. This is accomplished in the constructors.

Determining Object Behavior
In this section, you will learn how to create a simple class that describes the behavior of a bank account. Before you start programming, you need to understand how the objects of your class behave. Operations that can be carried out with a checking account could be:

Accepting a deposit
Withdrawing from the account
Getting the current balance
In Java, these operations are expressed as method calls. For example, assume we have an object checking of type CheckingAccount. Here are the methods that invoke the required behaviors:

checking.deposit(1000); 
checking.withdraw(250); 
System.out.println("Balance: " + checking.getBalance());

These methods form the behaviors of the CheckingAccount class. The behaviors are the list of methods that you can apply to objects of a given class. To the client, an object of type CheckingAccount can be viewed as a “black box” that can carry out its methods. The programming concept of not needing to know how things are done internally is called abstraction.

Once we understand what objects of the CheckingAccount class need to do, it is possible to design a Java class that implements these behaviors. To describe object behavior, you first need to implement a class and then implement methods within that class.



Next, we implement the three methods that have already been identified:

deposit
withdraw
getBalance


What we have been doing here is not real code and wouldn’t actually do anything. However, it is useful to lay out what your class will look like.

When we use a mixture of English and Java to show what we are doing, it is called pseudocode. In this example the implementation of the methods is left out because we do not have all the information that we need yet. However, we can still write out what the methods will do with pseudocode so that it becomes easier to see how everything will fit together.
This process of starting with a very broad concept or outline and working down to smaller and smaller details is called top-down design.


A method header consists of the following parts:

access_specifier return_type _method_name_ ( _parameters_ )

An access_specifier (such as public). The access specifier controls where this method can be accessed from. Methods should be declared as public if the method needs to be accessed by something other than the object containing the method. If it should only be accessed within the object, you should declare the method as private.

The return_type of the method such as double, void, or DrawingTool. The return type is the data type that the method sends back to the call of the method. This can be any primitive type or any object that your class knows about. For example, in the CheckingAccount class, the getBalance method returns the current account balance, which is a floating-point number, so its return type is double. The deposit and withdraw methods don’t return any value. To indicate that a method does not return a value, you use the keyword void.

The method_name (such as deposit). The name needs to follow the rules of identifiers and should indicate the method’s purpose.

A list of the parameters of the method. The parameters are the input to the method. The deposit and withdraw methods each have one parameter, the amount of money to deposit or withdraw. The type of parameter, such as double, and name for each parameter, such as amount, must be specified. If a method has no parameters, like getBalance, it is still necessary to supply a pair of parentheses () behind the method name.

Once the method header has been specified, the implementation of the method must be supplied in a block that is delimited by braces {...}. The CheckingAccount methods will be implemented later in Section D.

Instance Variables
Before any code can be written for the behaviors, the object must know how to store its current state.

The state is the set of attributes that describes the object and that influences how an object reacts to method calls. In the case of our checking account objects, the state includes the current balance and an account identifier.

Each object stores its state in one or more instance variables.



An instance variable declaration consists of the following parts:

access_specifier type variable_name

The access_specifier (such as private) tells who can access that data member. Instance variables are generally declared with the access specifier private. That means they can be accessed only by methods of the same class. In particular, the balance variable can be accessed only by the deposit, withdraw, and getBalance methods.

The type of the variable (such as double).

The variable_name (such as myBalance).

Data encapsulation
If instance variables are declared private, then all external data access must occur through the non-private methods. This means that the instance variables of an object are hidden.

The process of hiding data is called encapsulation. Although it is possible in Java to define instance variables as public (leave them unencapsulated), it is very uncommon in practice. In this curriculum, instance variables will always be made private.

For example, because the myBalance instance variable is private, it cannot be accessed from outside of the class:

double balance = checking.myBalance; // compiler ERROR!

However, the public getBalance method to inquire about the balance can be called:

double balance = checking.getBalance(); // OK

Implementing Methods
Now that we know how the object stores its state, we can provide the implementations for the methods of the class. The implementation for three methods of the CheckingAccount class is given below.



The implementation of the methods is straightforward. When some amount of money is deposited or withdrawn, the balance increases or decreases by that amount.

The getBalance method simply returns the current balance. A return statement obtains the value of a variable and exits the method immediately. The return value becomes the value of the method call expression. The syntax of a return statement is:

return expression;

or

return; // Exits the method without sending back a value, used in return-type void methods

Constructors
The final requirement to implement the CheckingAccount class is to define a constructor.

A constructor's purpose is to initialize the values of instance variables of an object. To construct objects of the CheckingAccount class, it is necessary to declare an object variable first.

CheckingAccount checking;

Object variables such as checking are references to objects. Instead of holding an object itself, a reference variable holds the information necessary to find the object in memory. This is the address of the object.

The object identifier checking does not refer to any object yet. An attempt to invoke a method on this variable would cause a runtime null pointer exception error. To initialize the variable, it is necessary to create a new CheckingAccount object using the new operator.

checking = new CheckingAccount();

Constructors are always invoked using the new operator. The new operator allocates memory for the objects, and the constructor initializes it. The “new” operator returns the reference to the newly constructed object.

In most cases, you will declare and store a reference to an object in an object identifier on one line as follows:

CheckingAccount checking = new CheckingAccount();

Occasionally, it would be repetitive and unnecessary to create an object identifier. If the purpose of creating the object is only to pass it in as an argument, you can simply create the object within the method call. For example, when creating DrawingTool objects, and you are providing a SketchPad object, you do not need to create an identifier for that SketchPad object:

DrawingTool pen = new DrawingTool(new SketchPad(500,500));

Notice that we never create an object identifier for the SketchPad object.

Conventions of constructors
Constructors always have the same name as their class.

Similar to methods, constructors are generally declared as public to enable any code in a program to construct new objects of the class. Unlike methods, constructors do not have return types.

Instance variables are automatically initialized with a default value (0 for number, false for boolean, null for objects). Even though initialization is handled automatically for instance variables, it is a matter of good style to initialize all instance variables explicitly. Generally, all of your instance variables should be initialized in your constructor.

Many classes define more than one constructor through overloading. For example, you can supply a second constructor for the CheckingAccount class that sets the myBalance and myAccountNumber instance variables to initial values, which are the parameters of the constructor:

Using Classes
Using the CheckingAccount class is best demonstrated by writing a program that solves a specific problem. We want to study the following scenario:

An interest bearing checking account is created with a balance of $1,000. For two years in a row, add 2.5% interest. How much money is in the account after two years?

Two classes are required: the CheckingAccount class that was developed in the preceding sections, and a second class called CheckingTester. The main method of the CheckingTester class constructs a CheckingAccount object, adds the interest twice, then prints out the balance.

Understanding APIs
API stands for Application Programming Interface and is one of the most useful tools you will have while working with Java. APIs show exactly how to use pre-made classes.

The DrawingTool Class Specifications handout in Lesson A1 is an example of a simplified API. It lists the classes and constructors so that we know which methods are available. APIs do not tell us how the programmer dealt with a problem or what kind of formulas they used internally, only telling us what methods we can access, how to interact with those methods, and what those methods will return to us.

You can always access the Java APIs at Oracle's Java website. Click on the version of Java you wish to retrieve the API for (likely 1.8 or the most recent one). You can download the APIs to your computer for offline access or access the online documentation. Many Java programming environments can be set up to access the APIs from within your code.

The Java APIs are organized both by package and by class. Packages are groups of related classes that are “packaged” together. When you use the code import gpdraw.*; you are adding the entire gpdraw package to your code. If you only need one or a few classes, for example, only the DrawingTool class from the gpdraw package, you can add the class(es) individually with the code import gpdraw.DrawingTool;.

Final and Static
Before you look at these APIs in depth, you need to learn what the keywords final and static mean, as they frequently come up in the API documentation.

The final keyword
When used with a primitive data type, final means that the value of the variable will never change.

This is useful in many cases, such as tax rates, math constants such as PI, and base values that are used in several places in your code. Identifiers with final are generally made with only capital letters, so they are easily distinguishable from the rest of the code.

final double TAXRATE = 0.0825; final double ROUNDS_IN_GAME = 100;

For example, a program that repeatedly uses a constant identifier, such as TAXRATE, can be quickly modified by assigning a value to TAXRATE at the top of the program.
If the value of the tax rate is hard coded everywhere it is used, then changing the tax rate would involve changing that value everywhere it appears in the program. This involves searching through your program and finding every single time that value is used, and then changing it to the new value. It would be easy to accidentally miss a value or two or possibly change something that was similar but wasn’t supposed to be the tax rate.
Using final values will not only save time but can also reduce the number of errors in your program.
Once a final variable is given a value within a program, that value may never change in that run.

In order to change that value, you must change it within your code, recompile, and run the program again. You may still define this value within the constructors so that the value can be determined at run time; it need not be defined at the same time that the variable is declared.

Objects and methods can also take a final keyword. However, they behave differently than primitive data types. We have not yet discussed the concepts that these final objects and methods affect, but we will cover them in Lesson A11 - Inheritance.

The static keyword
Using the keyword static means that the data member or method is attached to the class rather than to an object of that class.

With a static method, you only need to type the name of the class followed by the name of the method. You never need to create a new object when dealing with static methods. You can think of static methods as belonging to the class itself, whereas non-static methods are attached to the objects created from that class.

int jason = Math.pow(3,4);

jason receives and stores the result of 3 to the 4th power, which is 81.

Notice how there was never any need to create an object of type Math. Instead, we just have an int assigned the value created by the static pow method of the Math class.

Data members that are static may also be used without creating an object of that class.
They also have specific behavior when using that value of the data member within the class.
Even if we make a hundred objects of the same class, any static variables of that class will in fact be shared by all hundred of those objects.
If one object changes the value of that static variable, then the value is changed for all of the other objects of that type. This is because the variable and its value do not belong to any of the objects individually, but to the class itself.

DrawingTool
You have already been looking at an API for DrawingTool. The purpose of Handout A1.1 was to give you an introduction to the purpose of the class and how to use its various methods.

When instructed to draw a circle, you probably looked at Handout A1.1 and saw this:

public drawCircle (double r);

postcondition

-If the object is in drawing mode, a circle of radius r is drawn around the current location using the current width and color.

This tells us exactly what we need to know to use this method. We have the name of the method and the type of argument it takes. We also know what will happen after the method is called.

This is not the official Java format for an API, but it accomplishes the same thing. Without this handout, how would you have known how to draw a circle? How about when you made the picture of the house? How would you have known to use the forward method, turnLeft, down, or up? As you can see, APIs are an essential tool that must be looked at before a programmer can understand how to use pre-made classes.

Point2D.Double
The Point2D class is useful for storing locations on a two-dimensional space. It also contains several methods that can be used to do certain calculations. There are two subclasses of Point2D, but you will generally only want to use Point2D.Double.

Consider an application where you need to track the locations of two mice in a flat-bottomed box.

You could use two Point2D.Double objects to keep track of their locations.

What if we want to be able to tell how far apart the two mice are at any given time? We could use the distance formula from Geometry to calculate the distance. However, if we take a quick look at the Point2D API, we can find this method:

double | distance(Point2D pt)

Returns the distance from this Point2D to a specified Point2D.

A line of code as simple as

double distance = rat1.distance(rat2);

will give us the distance between the two rats. This is much simpler than trying to do all the calculations ourselves. Remember, whenever possible, we want to avoid writing code that has already been written. By doing a slight bit of research, we have saved ourselves the hassle of writing and then debugging code.

Random
As the name suggests, the java.util package is full of utility classes that you will find very useful. Many of them are going to be far too advanced for what you need at this stage, but as you progress in skill, you should browse through the classes and see which ones you begin to understand. During this course, you will learn several of the util classes in detail, but for now we will just concentrate on this one: java.util.Random.

Random is probably the most fun of all the classes in the java.util package! Any sort of game or in depth simulation (such as inspecting a transportation system to see how efficient it is) will generally need some sort of randomness in order to work the way we want. That’s where the Random class comes in. Let’s take a look at it now.

Constructor Summary
**Random**() Creates a new random number generator.
Method Summary	
double	nextDouble() Returns the next pseudorandom, uniformly distributed double value between 0.0 and 1.0 from this random number generator's sequence.
int	nextInt(int n)| Returns a pseudorandom, uniformly distributed int value between 0 (inclusive) and the specified value (exclusive), drawn from this random number generator's sequence.

These are the methods that you will be likely to find the most useful.

The constructor is very basic and requires no arguments. The word “pseudorandom” just indicates that the number is not completely random.
Computers are not physically capable of creating true random numbers. Therefore, in Computer Science, we refer to computer generated random numbers as “pseudorandom.”
Let’s look at a situation where we might use this class. Consider an electronic raffle for a prize. There are 200 participants with one number each between 1 and 200. We can create an object of type Random to determine who the winner is.

Random chooser = new Random();  
int winner = chooser.nextInt(200) + 1;
This code will give us a value between 1 and 200 in our winner variable.

Using Random
The Random class has many uses.

Most board games you have played probably use six sided dice to give the game an element of chance.
Video and computer games also use randomness to determine whether you hit your enemy or not, modified by the skill of the character you are using.
Think about the lottery as well. Without an element of chance, it would be pretty boring to buy lottery tickets and the game would cease to exist.

Math
The Math class in the java.lang package contains class methods for commonly used mathematical functions. Java loads the java.lang package automatically, so no special actions are required to access these.

The Math class contains both methods and the numerical values for two important mathematical constants, e and _π_. These constant values are accessed the same way as normal variables, but they can never be modified directly by your code.

The Math class is most useful for complex mathematical formulas, for example:



Using the Math class, we can create a line of code to solve this calculation much like you would type the same equation into your calculator:

(1.0/2.0) * Math.sin(x - Math.PI / Math.pow(y, 3));

Let’s see what other kind of methods the Math class provides for us.

Go ahead and take a look at the Java APIs. (Remember: Access the Java APIs on the Web at java.sun.com - click on API Specifications in the left column, and then pick the version of Java, such as J2SE 1.4.2, that you wish to see.)
Find the Math class within the Java.lang package. Hint: You can find it either in the long list of classes on the left hand side by scrolling down to the M section, or you can access the Java.lang package first in the upper left section and then look for the Math class. You should find something similar to this:


Field Summary	
E The double value that is closer than any other to e, the base of the natural logarithms. e	E The double value that is closer than any other to e, the base of the natural logarithms.
static double	PI The double value that is closer than any other to pi, the ratio of the circumference of a circle to its diameter.
Method Summary	
static double	**abs**(double a) Returns the absolute value of a double value.
static int	**abs**(int a) Returns the absolute value of an int value.
static double	**pow**(double a, double b) Returns the value of the first argument raised to the power of the second argument.
static double	**sqrt**(double a) Returns the correctly rounded positive square root of a double value.

The list shown here is much shorter than you will find online. However, let’s look at the layout.

At the very top is java.lang, the name of the package this class is in.
Below that is the name of the class, followed by a series of class names. You will learn more about this later, but for now just think of the classes listed there as the parents of the current class.
Below that comes the description of the class, which gives an introduction to the purpose of the class. This allows programmers to quickly decide if this class will do what they need.
Next is the list of attributes and behaviors, labeled as “Field Summary” and “Method Summary.”
The “Field Summary” section contains two items in it.

On the left side of the table, we can see they are both labeled as static double. This tells us the type of the variable, so we know how to use it.
On the right, we see the name of the variables followed by a brief description of it. If you are looking at this on the Internet, you can click on the name label (E or PI) to be taken to a more detailed description of the variable. We don’t generally need more information on variables, but the links are provided in the API just in case.
The “Method Summary” section has all of the available methods provided by the Math class.

Once again, we can see that the table is laid out in a similar manner, with a small section on the left and a larger section on the right. With the first listed method, abs, we can see the left section has the same label (static double) as we found with the E and PI values. However, this time it is telling us the return type of the methods.
On the right, we again get the name and a brief description, but we also get the arguments that must be passed to the method. Clicking on the name to go to the full description of methods is often much more useful than with the variables. If we click on the name abs we find much more information than we originally had with the short description:
abs

public static double **abs**(double a)

Returns the absolute value of a double value. If the argument is not negative, the argument is returned. If the argument is negative, the negation of the argument is returned. Special cases:

If the argument is positive zero or negative zero, the result is positive zero.
If the argument is infinite, the result is positive infinity.
If the argument is NaN, the result is NaN.
In other words, the result is the same as the value of the expression:
Double.longBitsToDouble((Double.doubleToLongBits(a)<<1)>>>1)

Parameters:
a - the argument whose absolute value is to be determined

Returns:
the absolute value of the argument.

Here we gain much more information about the abs method and what its purpose is. We learn some basics about what it does to the value. It even gives us some special cases that, while rare, can still occur. Note: NaN means Not a Number.

Here are some examples using the abs method.

Math.abs(25) -> 25

Math.abs(-25) -> 25

Math.abs(0) -> 0

Math.abs(17/5) -> 3

Javadoc Tool
The basics of creating your own APIs are pretty simple. When you add comments in your code, you can use the tag /**... */ before each class, variable, constructor, and method to create block comments. These comments work within your code in essentially the same way as the regular block comment tag /*...*/. However, once we run the Javadoc tool, APIs will be created based on these comments.

The first line of the comment should be a quick description that sums up what it is in front of. This first line will turn into the quick description that we discussed earlier. The rest of your paragraph should consist of a more detailed description of the item.

When you run your javadoc.exe program on your Java class file (as discussed in Handout A6.1, Javadocs), it will create a few .html files in the local directory. If you open up index.html with your Web browser, you will find yourself looking at an API created for your class.

After you understand and know how to run the javadoc tool by hand, you may be interested in the following tutorial.

How to create Javadocs using JCreator.
A tutorial by Elton Yang

If you are like me and using the command line on windows is too bothersome,
then i have a solution for you.

1. configure --> options
2. click on tools
3. click on new
4. select Program
5. browse and grab javadoc.exe
6. now you should have javadoc in the white box
7. click on the + to the left of Tools
8. click on javadoc(the left hand side one)
9. in the arguements section, use "-author -version -private $[JavaFiles]"
10. in the initial directory, i used "$[PrjDir]" to generate the javadocs in the project directory.
11. hit apply/ok
12. click on tools-->javadoc
13. watch as it runs
14. (optional) buy Elton a cookie for writing this tutorial

with this, jcreator has a javadocs tool.  if for some reason it doesn't work, download the
pro version and install it.  Its prettier and more efficient and i haven't needed to register yet.

Cheers,

-Elton Yang.

Reading Input with the Scanner Class
Some of the programs from the preceding lessons have been written without any flexibility. To change any of the data values in the programs, it is necessary to change the variable initializations, recompile the program, and run it again. Sometimes prompting the user for a value and then processing the data is more efficient and convenient.

However, accepting user input in Java can be complex. Throughout this curriculum, we will use the Scanner class to make processing input easier and less tedious.

Just as the System class provides System.out for output, there is an object for input, System.in. Unfortunately, Java’s System.in object does not directly support convenient methods for reading numbers and strings. We need to have a class sitting between the System.in object and ourselves to filter what comes through. This is what the Scanner class does.

Scanner is part of the java.util package, so we need to start off by adding the Scanner class to our import section.

import java.util.Scanner;

Next, we create our Scanner object and pass in the System.in object.

Scanner in = new Scanner(System.in);

This tells the Scanner to look at the System.in object for all of its input. In Student Lesson A13, we will learn how to change the object we pass to the Scanner so that we can read the data stored in text files.

Here are some example statements:



When the statement num1 = in.nextInt() is encountered, the program pauses until an appropriate value is entered on the keyboard.

Any whitespace (spaces, tabs, newline) will separate input values. When reading values, whitespace keystrokes are ignored.

When requesting data from the user via the keyboard, it is good programming practice to provide a prompt. An unintroduced input statement leaves the user hanging without a clue of what the program wants. For example:

System.out.print("Enter an integer --> ");
number = in.nextInt();

Multiple Line Stream Output Expressions
We have already used examples of multiple output statements such as:

System.out.println("The value of sum = " + sum);

When the length of an output statement exceeds one line of code, it can be broken up several different ways:

System.out.println("The sum of " + num1 + " and " + num2 +
                " = " + (num1 + num2));
or
System.out.print("The sum of " + num1 + " and " + num2);
System.out.println( " = " + (num1 + num2));

You cannot break up a String constant and wrap it around a line.

System.out.print("A long string constant must be broken
up into two separate quotes. This will NOT work.");

System.out.print("A long string constant must be broken up"
            + " into two separate quotes. This will work.");

Formatting Output
To format, we will learn a new printing method, printf(). It works similarly to the print() and println() methods that you have already been using to output text.

The printf() method takes two arguments. The first one is the formatting String, a special sequence of characters that tells printf() how to display the second argument. The syntax for the formatting String is:

%[flags][width][.precision]conversion

The '%' sign tells the printf method that formatting is coming. All of your formatted String constants will start with %. It does not have to be the very first thing in your String constant, just the first part of any formatted text.

The last part of the formatting String, conversion, is one of the most important parts. It is what determines how the printf() method reacts to a message you send it. The most important conversion tags for you to know are 's', 'd', and 'f'. 'd' is used for integers (base-10 notation), 'f' is for numbers with decimal places (doubles), and 's' is for String literals. The conversion tag always comes at the end of the formatting String.

Conversion Tag	Usage Type	Example
s	String literals	printf("%s", "Sam")
d	ints	printf("%d", 5182)
f	doubles	printf("%f", 2.123456)

Precision is very easy and straightforward. When using a formatting String with the 's' conversion tag, this will tell printf() the maximum number of characters to print out. When used with the 'f' conversion tag, you can specify how many decimal places to print out, rounded to the closest number. If you don't specify how many decimal places to display with 'f' then it will default to six places.

System.out.printf("%.2s", "Hello") -> He
System.out.printf("%.10s", "Hello") -> Hello
System.out.printf("%.5f", Math.PI) -> 3.14159
System.out.printf("%.4f", Math.PI) -> 3.1416
System.out.printf("%f", Math.PI) -> 3.141593


Width tells printf() the minimum number of characters to print out. This allows for creating right-aligned lists or menus. printf() does not distinguish between normal characters and special characters (escape sequences), so "Prices:" and "Prices:\n" are two different sizes. If you want to print your data out left-aligned, you can simply add a '-' character to the left of the width value.

Note: In the example below, the first line has a width of 11 instead of 10 to adjust for the \n error. Because numeric entries cannot use these special characters, it is better to use println() to separate lines when utilizing printf(). The example below shows one instance of using the \n character as well as doing two columns of formatted output.

System.out.printf("%-10s", "Name:");
System.out.printf("%11s", "Price:\n");
System.out.printf("%-10s", "Soda");
System.out.printf("%10.2f", 10.25);
System.out.println();
System.out.printf("%-10s", "Candy");
System.out.printf("%10.2f", 1.50);


Output:

Name:      Price:
Soda        10.25
Candy        1.50

Flags are special characters that give special properties to the values passed in. Adding a '+' sign in the formatting String will give numbers a positive or negative sign when printed. Putting in a '(' will cause negative numbers to be enclosed with parentheses. The most useful of the flags is ',' because it will add commas into large numbers (in the correct spot for the region, i.e. Japan puts numbers into groups of four unlike the US, which puts numbers in groups of three). To get a dollar sign directly before your printed value, place the '$' character directly before the '%' sign.

System.out.printf("%,d", 12345678) -> 12,345,678
System.out.printf("$%,d", 12345678) -> $12,345,678
System.out.printf("%,(d", 12345678) -> 12,345,678
System.out.printf("%,(d", -12345678) -> (12,345,678)

You may put multiple arguments in one call to printf() for organizational purposes. Simply put multiple formatting Strings in the first passed argument to printf() and then add your additional arguments, separated by commas.

double mySum = 123.456
System.out.printf("%10s %10.2f", "Total:", mySum);

This curriculum uses just a few of the many things that printf() is capable of. Once you get more familiar with using the formatting options shown in this guide, you can look at the API for the Formatter class for more information on formatting Strings. The printf() method is an easy way to manage the Formatter class in a way that is very similar to the common print() and println() functions.

Structured Programming
In the early days of programming (1960's), the approach to writing software was relatively primitive and ineffective. Much of the code was written with goto statements that transferred program control to another line in the code. Tracing this type of code was an exercise in jumping from one spot to another, leaving behind a trail of lines similar to spaghetti. The term "spaghetti code" comes from trying to trace code linked together with goto statements. The complexity this added to code led to the development of structured programming.

The research of Bohm and Jacopini has led to the rules of structured programming. Here are five tenets of structured programming.

No goto statements are to be used in writing code.
All programs can be written in terms of three control structures: sequence, selection, and iteration.
Each control structure has one entrance point and one exit point. We will sometimes allow for multiple exit points from a control structure using the break statement.
Control structures may be stacked (sequenced) one after the other.
Control structures may be nested inside other control structures.
The control structures of Java encourage structured programming. Staying within the guidelines of structured programming has led to great productivity gains in the field of software engineering.

Control Structures
There are only three necessary control structures needed to write programs: sequence, selection, and iteration.

Sequence refers to the line-by-line execution as used in your programs so far. The program enters the sequence, does each step, and exits the sequence. This allows for sequences to do only a limited job during each execution.

Selection is the control structure that allows choice among different paths. Java provides different levels of selection:

One-way selection with an if structure
Two-way selection with an if-else structure
Multiple selection with a switch structure
Iteration refers to looping. Java provides three loop structures. These will be discussed in length in Student Lesson A12.

while loops
do-while loops
for loops

Algorithm Development and Psuedocode
An algorithm is a solution to a problem. Computer scientists are in the problem-solving business. They use techniques of structured programming to develop solutions to problems. Algorithms will range from the easier "finding the average of two numbers" to the more difficult "visiting all the subdirectories on a hard disk, searching for a file."

A major task of the implementation stage is the conversion of rough designs into refined algorithms that can then be coded in the implementation language of choice.

Pseudocode refers to a rough-draft outline of an answer, written in English-like terms. These generally use phrases and words that are close to programming languages, but avoid using any specific language syntax. Once the pseudocode has been developed, translation into code occurs more easily than if we had skipped this pseudocode stage.

Stepwise refinement is the process of gradually developing a more detailed description of an algorithm. Problem solving in computer science involves overall development of the sections of a program, expanding each section with more detail, later working out the individual steps of an algorithm using pseudocode, and then finally writing a code solution.

Relational Operators
A relational operator is a binary operator that compares two values. The following symbols are used in Java as relational operators:

<   less than  
>   greater than  
<=  less than or equal to  
>=  greater than or equal to  
==  equal to  
!=  not equal to

A relational operator is used to compare two values, resulting in a relational expression. For example:

number > 16        grade == 'F'        passing >= 60 

The result of a relational expression is a boolean value of either true or false.

When character data is compared, the ASCII code values are used to determine the answer. The following expressions result in the answers given:

'A' < 'B'    evaluates as true, (65 < 66)
'd' < 'a'    evaluates as false, (100 < 97)
't' < 'X'    evaluates as false, (116 < 88)

In the last example, you must remember that upper case letters come first in the ASCII collating sequence; the lower case letters follow after and consequently have larger ASCII values than do upper case ('A' = 65, 'a' = 97).

Logical Operators
The three logical operators in the AP subset are AND, OR, and NOT. These operators are represented by the following symbols in Java:

AND        &&
OR         || (two vertical bars)
NOT        !

These logical operators allow us to combine conditions. For example, if a dog is gray and weighs less than 15 pounds it is the perfect lap dog.

The && (and) operator requires both operands (values) to be true for the result to be true.

(true && true) -> true
(true && false) -> false
(false && true) -> false
(false && false) -> false

The following are Java examples of using the && (and) operator.

((2 < 3) && (3.5 > 3.0)) -> true
((1 == 0) && (2 != 3)) -> false

The && operator performs short-circuit evaluation in Java. If the first operand in && statement is false, the operator immediately returns false without evaluating the second half.

The || (or) operator requires only one operand (value) to be true for the result to be true.

(true || true) -> true
(true || false) -> true
(false || true) -> true
(false || false) -> false

The following is a Java example of using the || (or) operator.

((2+3 < 10) || (19 > 21)) -> true

The || operator also performs short-circuit evaluation in Java. If the first half of an || statement is true, the operator immediately returns true without evaluating the second half.

The ! operator is a unary operator that changes a boolean value to its opposite.

(! false == true) -> true
(! true == false) -> true
(! true == true) -> false
!(2 < 3) -> false

Precedence and Associativity of Operators
Introducing two new sets of operators (relational and logical) adds to the complexity of operator precedence in Java. An abbreviated precedence chart is included here.

Operator	Associativity
! unary - ++ --	right to left
* / %	left to right
+ -	left to right
< <= > >=	left to right
== !=	left to right
&& (and)	left to right
|| (or)	left to right
= += -= *= /=	right to left
Table 8-1 Precedence and Associativity of Operators

Because the logical operators have low precedence in Java, parentheses are not needed to maintain the correct order of solving problems. However, they can be used to make complex expressions more readable.

((2 + 3 < 10) && (75 % 12 != 12)) // easier to read
(2 + 3 < 10 && 75 % 12 != 12)     // harder to read

The if-else Statements
The general syntax of the if statement is as follows:

if (expression) {
    statement1;
}

If the expression evaluates to true, statement1 is executed. If expression is false then nothing is executed and the program execution picks up after the ending curly brace (}). The following diagram shows the flow of control:



To provide for two-way selection an if statement may add an else option.

if (expression) {
    statement1;
}
else {
    statement2;
}

If the expression evaluates to true, the statement is executed. In an if-else statement, if the expression is false then statement2 would be executed. The following flowchart illustrates the flow of control.



The expression being tested must always be placed in parentheses. This is a common source of syntax errors.

Compound Statements
The statement executed in a control structure can be a block of statements, grouped together into a single compound statement.

A compound statement is created by enclosing any number of single statements by braces as shown in the following example:

if (expression) {
    statement1;
    statement2;
    statement3;
}
else {
    statement4;
    statement5;
    statement6;
}

Nested if-else Statements
The statement inside of an if or else option can be another if-else statement. Placing an if-else inside another is known as nested if-else constructions.

if (expression1){
    if (expression2){
        statement1;
    }else{
        statement2;
    }
}else{
    statement3;
}

Here, your braces will need to be correct to ensure that the ifs and elses get paired with their partners.

The above example has three possible different outcomes as shown in the following chart:

Technically, braces are not needed for if and if-else structures if you only want one statement to execute. However, caution must be shown when using else statements inside of nested if-else structures. For example:

if (expression1)
    if (expression2)
        statement1;
    else
statement2;

Indentation is ignored by the compiler, hence it will pair the else statement with the inner if. If you want the else to get paired with the outer if as the indentation indicates, you need to add braces:

if (expression1){
    if (expression2)
        statement1;
    }else
statement2;

The braces allow the else statement to be paired with the outer if.

Important Concept: However, if you always use braces when writing if and if-else statements, you will never have this problem.

Another alternative to the example in Section 4 makes use of the && operator. A pair of nested if statements can be coded as a single compound && statement. Both of these blocks of code would have the exact same effect, but the second one is slightly easier to read.

if(expression1){
    if(expression2){
        statement1;
    }
}

//or...

if (expression1 && expression2){
    statement1;
}

The second block of code makes the conditions clearer to another programmer.

Consider the following example of determining the type of triangle given the three sides A, B, and C.

if ( (A == B) && (B == C) )
    System.out.println("Equilateral triangle");
else if ( (A == B) || (B == C) || (A == C) )
    System.out.println("Isosceles triangle");
else
    System.out.println("Scalene triangle");

If an equilateral triangle is encountered, the rest of the code is ignored. This can help to reduce the execution time of a program.

Conditional Operator
Java provides an alternate method of coding an if-else statement using the conditional operator. This operator is the only ternary operator in Java, as it requires three operands. The general syntax is:

(condition) ? value1 : value2;

If the condition is true, value1 is returned. If the condition is false, value2 is returned.

This is appropriate in situations where the condition is fairly compact and the result is a value or object. Here are three examples.

/** returns the larger of two integers */
int max(int a, int b) {
    return (a > b) ? a : b;
}

// bonus is set to $100 if more than 60 hours are worked, $0 otherwise
bonus = (hoursWorked > 60) ? 100 : 0;

// name is set to the cooler of the two people
name = (bobCoolFactor > joeCoolFactor) ? "Bob" : "Joe";

Boolean Identifiers
The execution of if-else statements depends on the value of the Boolean expression. We can use boolean variables to write code that is easier to read.

For example, the boolean variable done could be used to write code that reads more like English.

Instead of
if(done == true){
    System.out.println("We are done!");
}
we can write
if(done){
    System.out.println("We are done!");
}

Programmers often use boolean variables to aid in program flow and readability. The second version is the more preferred way of using a boolean variable in this situation because it is less dangerous. If you make a mistake and only put = instead of == Java will not catch that and interprets the statement as assignment. Some strange results could occur and it can take the programmer a while to catch the error.

Switch Statements (Optional)
Consider a simple user menu for a store simulation program. There should be options to buy certain items, check your total money spent, cancel items selected, exit, and finish and pay. We could take the input from this menu and do a complicated, nested series of if-else statements, but that would quickly become bulky and difficult to read. However, there is an easy way to handle such data input with a switch statement. Depending on which command is chosen, the program will select one direction out of many. The AP exam does not test on the switch statement, but we include it here at the end of this chapter because it is a very useful tool to have in your programming toolkit.

The general form of a switch statement is:



The flow of control of a switch statement is illustrated in this diagram:



The switch statement attempts to match the integer value of the expression with one of the case values.

If a match occurs, then all statements past the case value are executed until a break statement is encountered.

The effect of the break statement causes program control to jump to the end of the switch statement. No other cases are executed.

A very common error when coding a switch control structure is forgetting to include the break statements to terminate each case value. If the break statement is omitted, all the statements following the matching case value are executed. This is usually very undesirable.

If it is possible that none of the case statements will be true, you can add a default statement at the end of the switch. This will only execute if none of the case statements happened. If all possibilities are covered in your case statements, the default statement is unnecessary. Note that the default statement can actually be placed anywhere. If you place the default in the beginning or middle of the switch, you will probably want to end the default case with a break. Otherwise, execution will continue with the case after the default.



The following example applies the switch statement to printing the work day of the week corresponding to a value. We pass in the integer day:



Suppose we wanted to count the occurrences of vowels and consonants in a stream of text.



Note that multiple case values can lead to one set of statements.
It is good programming practice to include a break statement at the end of the switch structure. If you need to go back and add another case statement at the end of the switch structure, a break statement already terminates the previous case statement and there is no chance that you might forget to add a break statement.
There are programming situations where the switch statement should not replace an if-else chain. If the value being compared must fit in a range of values, the if-else statement should be used.



etc...

You should not replace the above structure with a switch statement.

Finally, the switch statement cannot compare double values.

Recursion
Recursion occurs when a method calls itself to solve another version of the same problem.

With each recursive call, the problem becomes simpler and moves towards a base case. A base case is when the solution to the problem can be calculated without another recursive call.

Recursion involves the internal use of a stack. A stack is a data abstraction that works like this: New data is "pushed," or added to the top of the stack. When information is removed from the stack it is "popped," or removed from the top of the stack. The recursive calls of a method will be stored on a stack and manipulated in a similar manner.

The problem of computing factorials is our first example of recursion. The factorial operation in mathematics is illustrated below.

1! = 1
2! = 2 * 1               or        2 * 1!
3! = 3 * 2 * 1           or        3 * 2!
4! = 4 * 3 * 2 *1        or        4 * 3!

Notice that each successive line can be solved in terms of the previous line. For example, 4! is equivalent to 4 * 3!

A recursive method to solve the factorial problem is given below. Notice the recursive call in the last line of the method. The method calls another implementation of itself to solve a smaller version of the problem.

int fact(int n){  
    // returns the value of n!  
    // precondition: n >= 1  
    if (n == 1){  
        return 1;  
    }else{
        return n * fact(n - 1);  
    }  
}
The base case is a fundamental situation where no further problem-solving is necessary. In the case of finding factorials, 1! is by definition 1. No further work is needed. Each recursive method must have at least one base case.

Suppose we call the method to solve fact(4). This will result in four calls of method fact.

When a recursive call is made, the current computation is temporarily suspended and placed on the stack with all its current information available for later use.

A completely new copy of the method is used to evaluate the recursive call. When that is completed, the value returned by the recursive call is used to complete the suspended computation. The suspended computation is removed from the stack and its work now proceeds.

When the base case is encountered, the recursion will now unwind and result in a final answer. The expressions below should be read from right to left.



Figure 9.1 below diagrams what happens:



Figure 9.1 - Recursive Boxes

Each box represents a call of method fact. To solve fact(4) requires four calls of method fact.

Notice that when the recursive calls were made inside the else statement, the value fed to the recursive call was (n-1). This is where the problem is getting simpler with the eventual goal of solving 1!.

Pitfalls of Recursion
If the recursion never reaches a base case, the recursive calls will continue until the computer runs out of memory and the program crashes. Experienced programmers try to examine the remains of a crash. The message “stack overflow error” or “heap storage exhaustion” indicates a possible runaway recursion.

When programming recursively, you need to make sure that the algorithm is moving toward a base case. Each successive call of the algorithm must be solving a version of the problem that is closer to a base case.

The String Class
Groups of characters in Java are not represented by primitive types as are int or char types. Strings are objects of the String class. The String class is defined in java.lang.String, which is automatically imported for use in every program you write. We’ve used String literals, such as "Enter a value" with System.out.print statements in earlier examples. Now we can begin to explore the String class and the capabilities that it offers.

So far, our experience with Strings has been with String literals, consisting of any sequence of characters enclosed within double quotation marks. For example:

"This is a string"
"Hello World!"
"\tHello World!\n"

The characters that a String object contains can include escape sequences. This tab contains a tab (\t) and a linefeed (\n) character.

A second unique characteristic of the String class is that it supports the "+" operator to concatenate two String expressions. For example:

String sentence = "I " + "want " + "to be a " + "Java programmer.";

The "+" operator can be used to combine a String expression with any other expression of primitive type. When this occurs, the primitive expression is converted to a String representation and concatenated with the string. For example, consider the following instruction sequence:

double PI = 3.14159;
System.out.println("The value of PI is " + PI);

Run Output:

The value of PI is 3.14159

To invoke the concatenation, at least one of the items must be a String.

String Constructors
Because Strings are objects, you can create a String object by using the keyword new and a String constructor method, just as you would create any other object.

String name = new String();
String name2 = new String(“Nancy”);

Though they are not primitive types, strings are so important and frequently used that Java provides additional syntax for declaration:

String aGreeting = "Hello world";

A String created in this short-cut way is called a String literal. Only Strings have a shortcut like this. All other objects are constructed by using the new operator.

Many new Java programmers get confused because of this shortcut and believe that Strings are primitive data types. However, Strings are objects and therefore have behaviors and attributes.

Object References
Recall from Lesson A2 that an object is constructed as an instance of a particular class. Objects are referenced using an identifier called a reference variable. Unlike primitives, which directly store their data in the associated variable, object references store only a reference to where the data can be found in memory. Now that we are working with a simple class, String, it is a good time to discuss object references.

Whenever the new operator is used, a new object is created. Each time an object is created, it is stored in some address in memory and that address can be saved in a reference variable to be accessed later. The reference is used to find the object, much like a street address is used to find a location where someone lives and stores all their stuff. When creating an object reference in Java, the variable stores the memory location where the object can be found rather than store the contents of the object directly.

It is possible to store a new object reference in a variable. For example:

String str;

str = new String("first string");
System.out.println(str);

str = new String("second string");
System.out.println(str);

Run Output:

first string
second string

In the example above, the variable str is used to store a reference to a String object that stores the text, “first string”. In the second part of the example a reference to a String that stores the text, “second string” is stored in the variable str. If another reference is saved in the variable, it replaces the previous reference because each reference variable can only point to one object at any given time (see diagram below).



If a reference to an object is no longer being used then there is no way to find it, and it becomes "garbage." The word "garbage" is the correct term from computer science to use for objects that have no references. This is a common situation when new objects are created and old ones become unneeded during the execution of a program. While a program is running, a part of the Java system called the "garbage collector" reclaims each lost object (the "garbage") so that the memory is available again. In the above example, the String object “first string” becomes garbage.

Multiple objects of the same class can be created by using the new keyword.

String strA; // a reference variable
String strB; // another reference variable

// create the first object and save its reference in a reference variable
strA = new String("first string");

// print data referenced by the first object.
System.out.println(strA);

// create the second object and save its reference in a reference variable
strB = new String("second string");

// print data referenced by the second object.
System.out.println(strB);

// print data referenced by the first object.
System.out.println(strA);

Run Output:

first string
second string
first string

This program has two reference variables, strA and strB. It creates two objects and places a reference to each object in one of the variables. Since each object has its own reference variable, no reference is lost, and no object becomes garbage (until the program has finished running).



Different reference variables that refer to the same object are called aliases. In effect, there are two names for the same object. For example:

String strA; // declare a reference variable
String strB; // declare another reference variable

// Create the only object and save its
// reference in strA
strA = new String("only one string");
System.out.println(strA);

strB = strA; // copy the reference to strB.
System.out.println(strB);

Run Output:

only one string
only one string



When this program runs, only one object is created by the new keyword. (Technically, a String literal is also created but no reference to it is saved - see below for more about this.) Information about how to find the object (its memory address) is stored in strA. The assignment operator in the statement

strB = strA; // copy the reference to strB

copies the address stored in strA to strB. It does not make a copy of the actual object. It is like writing the address to your house on two different pieces of paper - doing so does not create two houses.

String Pool and Counting String Objects
A String literal is any hardcoded string such as "I love Java." Even when reference variables are used, the portion in quotations is a String literal. For example, String str = new String("Hello"); passes the String literal "Hello" into a String constructor.

In order to save resources, Java keeps track of String literals in a String Pool. The String Pool is an area of memory used to store exactly one copy of each distinct String literal. Each String literal is considered a String object. Multiple of the same string literals will only be saved once in the String pool and thus counts as only one object. This is very important for counting string objects. Distinct string literals create one string object for each distinct string literal. In this way, Java eliminates storing duplicates of the same String values. Consider this example:

String strA = "only one string";
String strB = "only one string";
System.out.println(strA == strB); // Prints true

The line: String str = new String(new String("String literal")); creates three String objects because there are two new keywords and one string literal ("String literal").


When Java encounters "only one string" the first time, it adds "only one string" to the String Pool and the reference variable 'strA' points to it. When Java sees the second occurrence of "only one string" it looks in the String Pool table and sees that there is already an instance of "only one string" so another copy is not created. Instead, the reference variable 'strB' points to the existing "only one string" in the String Pool.

How many objects are created in the previous example? Only one object is created because both 'strA' and 'strB' refer to the same copy of "only one string" stored in the String Pool.

However, Java always creates a new object when a constructor is used. Consider this example:

String one = "Hello";
String two = new String("Hello");
System.out.println(one == two); // Prints false




In this case, two objects are created: One object for the two String literals ("Hello") and a second object to store the object 'two.'

Behind the scenes, Strings are stored as immutable (unchangeable) character arrays. In the case of String 'two' the character array used will point back to the original "Hello" but the overall object in which this happens is a separate address from the String literal.

Here is another example:

String str = new String("HI");
System.out.println(str == "HI"); // prints false (str is not the same object as "HI")
System.out.println(str.equals("HI")); // prints true (str stores the same characters in the same order as "HI")
// Two objects are created, but only one object is accessible

The literal "HI" creates a String object that says "HI" and stores it in the string pool. The new keyword also creates a String object and stores a reference to it in the variable str. The String str references the same character array as the literal "HI", so it contains the same characters in the same order, but str does NOT reference the same object as the String literal "HI". Thus, two objects are created, but only one is accessible with a reference variable (the object str is pointing to).

Want to know more? Search for "Java String Pool" online or see the section on String Literals in the Java Language Specification.

The null Value
In most programs, objects are created and objects are destroyed, depending on the data and on what is being computed. A reference variable sometimes does and sometimes does not refer to an object. You may need a way to erase the reference inside a variable without creating a new reference. You do this by assigning null to the variable.

The value null is a special value that means "no object." A reference variable is set to null when it is not referring to any object.

String a =                // 1. an object is created;
   new String("stringy"); // variable a refers to it
String b = null;          // 2. variable b refers to no
                          // object.
String c =                // 3. an object is created
   new String("");        // (containing no characters)
                          // variable c refers to it
if (a != null)            // 4. statement true, so
System.out.println(a);    // the println(a) executes.

if (b != null)            // 5. statement false, so the
System.out.println(b);    // println(b) is skipped.

if (c != null)            // 6. statement true, so the
System.out.println(c);    // println(c) executes (but
                          // it has no characters to
                          // print).
Run Output:

stringy

Variables a and c are initialized to object references. Variable b is initialized to null. Note that variable c is initialized to a reference to a String object containing no characters. Therefore, println(c) executes, but it has no characters to print. Having no characters is different from the value being null.

String Query Methods
Query Method	Sample Syntax
int length();	String str1 = "Hello!";
int len = str1.length(); // len == 6
char charAt(int index);	String str1 = "Hello!";
char ch = str1.charAt(0); // ch == 'H'
int indexOf(String str);	String str2 = "Hi World!";
int n = str2.indexOf("World"); // n == 3
int n = str2.indexOf("Sun"); // n == -1
int indexOf(char ch);	String str2 = "Hi World!";
int n = str2.indexOf('!'); // n == 8
int n = str2.indexOf('T'); // n == -1

The int length() method returns the number of characters in the String object.

The charAt method is a tool for extracting a character from within a String. The charAt parameter specifies the position of the desired character (0 for the leftmost character, 1 for the second from the left, etc.). For example, executing the following two instructions prints the char value 'X'.

String stringVar = "VWXYZ"
System.out.println(stringVar.charAt(2));

The int indexOf(String str) method will find the first occurrence of str within this String and return the index of the first character. If str does not occur in this String, the method returns -1.

The int indexOf(char ch) method is identical in function and output to the other indexOf function except it is looking for a single character.

String Translation Methods
Translate Method	Sample Syntax
String toLowerCase();	String greeting = "Hi World!";
greeting = greeting.toLowerCase();
// greeting <- "hi world!"
String toUpperCase();	String greeting = "Hi World!";
greeting = greeting.toUpperCase();
// greeting <- "HI WORLD!"
String trim();	String needsTrim = " trim me! ";
needsTrim = needsTrim.trim();
// needsTrim <- "trim me!"
String substring(int beginIndex);	String sample = "hamburger!";
// sample <- "burger"
String substring(int begin, int end);	String sample = "hamburger!";
// sample <- "urge"
toLowerCase() returns a String with the same characters as the String object, but with all characters converted to lowercase. Notice that in all of the above samples, the String object is placed on the left-hand side of the assignment statement. This is necessary because Strings in Java are immutable. Please see section G for a full explanation of immutable.

toUpperCase() returns a String with the same characters as the String object, but with all characters converted to uppercase.

trim() returns a String with the same characters as the String object, but with the leading and trailing whitespace removed.

substring(int beginIndex) returns the substring of the String object starting from beginIndex through to the end of the String object.

substring(int beginIndex, int endIndex) returns the substring of the String object starting from beginIndex through, but not including, position endIndex of the String object. That is, the new String contains characters numbered beginIndex to endIndex-1 in the original String.

Immutability of Strings
Immutability of Strings means you cannot modify any String object.

Notice the above example for the method toLowerCase. This method returns a new String, which is the lower case version of the object that invoked the method.

String greeting = "Hi World!";
greeting.toLowerCase();
System.out.println(greeting);

Run Output:

Hi World!

The object greeting did not change. To change the value of greeting, you need to assign the return value of the method to the object greeting.

greeting = greeting.toLowerCase();
System.out.println(greeting);

Run Output:

hi world!

Comparing Strings
Comparison Method	Sample Syntax
boolean equals(String other)	String aName = "Mat";
String anotherName = "Mat";
if (aName.equals(anotherName))
System.out.println("the same");
boolean equalsIgnoreCase(String other)	String aName = "Mat";
if (aName.equalsIgnoreCase("MAT"))
System.out.println("the same");
int compareTo(String other)	String aName = "Mat";
n = aName.compareTo("Rob"); // n < 0
n = aName.compareTo("Mat"); // n == 0
n = aName.compareTo("Amy"); // n > 0

The equals() method evaluates the contents of two String objects to determine if they are equivalent. The method returns true if the objects have identical contents. For example, the code below shows two String objects and several comparisons. Each of the comparisons evaluates to true; each comparison results in printing the line "Name's the same".

String aName = "Mat";
String anotherName = new String("Mat");

if (aName.equals(anotherName))
   System.out.println("Name's the same");

if (anotherName.equals(aName))
   System.out.println("Name's the same");

if (aName.equals("Mat"))
   System.out.println("Name's the same");

Each String shown above, aName and anotherName, is an object of type String, so each String has access to the equals() method. The aName object can call equals() with aName.equals(anotherName), or the anotherName object can call equals() with anotherName.equals(aName). The equals() method can take either a variable String object or a literal String as its argument.

In all three examples above, the boolean expression evaluates to true.

The == operator can create some confusion when comparing objects. The == operator will check the reference value, or address, of where the object is being stored. It will not compare the data members of the objects. Because Strings are objects and not primitive data types, Strings cannot be compared with the == operator. However, due to the shortcuts that make String act in a similar way to primitive types, two Strings created without the new operator but with the same String literal will actually point to the same address in memory. Observe the following code segment and its output:

String aGreeting1 = new String("Hello");
String anotherGreeting1 = new String("Hello");

if (aGreeting1 == anotherGreeting1)
   System.out.println("This better not work!");
else
   System.out.println("This prints since each object " +
      "reference is different.");

String aGreeting2 = "Hello";
String anotherGreeting2 = "Hello";


if (aGreeting2 == anotherGreeting2)
   System.out.println("This prints since both " +
      "object references are the same!");
else
   System.out.println("This does not print.");

Run Output:

This prints since each object reference is different.
This prints since both object references are the same!

The objects aGreeting1 and anotherGreeting1 are each instantiated using the new command, which assigns a different reference to each object. The == operator compares the reference to each object, not their contents. Therefore, the comparison (aGreeting1 == anotherGreeting1) returns false since the references are different.

The objects aGreeting2 and anotherGreeting2 are String literals (created without the new command - i.e. using the short-cut instantiation process unique to Strings). In this case, Java recognizes that the contents of the objects are the same, and it creates only one instance, with aGreeting2 and anotherGreeting2 each referencing that instance. Since their references are the same, (aGreeting2 == anotherGreeting2) returns true.

When comparing objects to see if they are equal, always use the equals method. It would be a rare occasion to care if they are occupying the same memory location. Remember that a String is an object!

The equalsIgnoreCase() method is very similar to the equals() method. As its name implies, it ignores case when determining if two Strings are equivalent. This method is very useful when users type responses to prompts in your program. The equalsIgnoreCase() method allows you to test entered data without regard to capitalization.

The compareTo() method compares the calling String object and the String argument to see which comes first in the lexicographic ordering. Lexicographic ordering is the same as alphabetical ordering when both strings are either all uppercase or all lowercase. If the calling string is first lexicographically, it returns a negative value. If the two strings are equal, it returns zero. If the argument string comes first lexicographically, it returns a positive number.

String bob = “Bob”;
String bob2 = “bob”;
String steve = “Steve”;
System.out.println(bob.compareTo(bob2));
System.out.println(bob2.compareTo(bob));
System.out.println(steve.compareTo(bob2));
System.out.println(bob.compareTo(steve));

The output for this block of code would be:

-32
32
-15
-17

Strings and Characters
It is natural to think of a char as a String of length 1. Unfortunately, in Java the char and String types are incompatible since a String is an object and a char is a primitive type. This means that you cannot use a String in place of a char or use a char in place of a String.

Extracting a char from within a String can be accomplished using the charAt method as previously described.

Conversion from char to String can be accomplished by using the "+" (concatenation) operator described previously. Concatenating any char with an empty string (String of length zero) results in a string that consists of that char. The java notation for an empty string is two consecutive double quotation marks. For example, to convert myChar to a String it is added to “”.

char myChar = ‘X’;
String myString = "" + myChar;
System.out.println(myString);
char anotherChar = ‘Y’;
myString += anotherChar;
System.out.println(myString);

The output of this block of code would be:

X
XY

The toString method
Wouldn’t it be nice to be able to output objects that you have made using the simple line System.out.print(Object name)? Let’s consider the example of the RegularPolygon class discussed in Lesson A6. It would be nice to be able to print out the statistics of your RegularPolygon objects without having to do a lot of System.out.print statements. Thanks to the toString method, you have the ability to do this.

You can create a toString method in any of your classes in the format of public String toString(). Within the toString() method, you can format your class variables into one String object and return that String. Then, when Java encounters your Object in a String format, it will call the toString() method. Let’s look at an example using a RegularPolygon class.

public String toString(){
    String a = “Sides: ” + getSides();
    a += “ Length: ” + getLength();
    a += “ Area: ” + getArea();
    return a;
}

RegularPolygon square = new RegularPolygon(4, 10);
System.out.println(square);

Run Output:

Sides: 4 Length: 10 Area: 100

You must be careful when using this, because you are fixing the format of the output. Oftentimes, you will still want to format your output depending on the specific problem you are solving, but the toString() method provides a simple and quick way to look at the state of your objects. There are also many times when the toString() method will be very useful. Consider a Student class that contains member variables for first name, middle name, last name, a list of classes being taken, the student’s address and phone number, etc. You could easily make a toString() method that would simply output the students first name, middle initial, and last name for quick reference. Every time you design a class, you should stop and think about whether or not your class would benefit from having a toString() method and how you should format this String.

String I/O
The Scanner class has two methods for reading textual input from the keyboard.

The next method returns a reference to a String object that has from zero to many characters typed by the user at the keyboard. The String will end whenever it reaches white space. White space is defined as blank spaces, tabs, or newline characters in the input stream. When inputting from the keyboard, next stops adding text to the String object when the first white space is encountered from the input stream.

A nextLine method returns a reference to a String object that contains from zero to many characters entered by the user. With nextLine, the String object may contain blank spaces and tabs but will end when it reaches a newline character. Therefore, nextLine will read in whole lines of input rather than only one word at a time.

String input is illustrated below.

Scanner keyboard = new Scanner(System.in);
String word1, word2, anotherLine;

// prompt for input from the keyboard
System.out.print("Enter a line: ");

// grab the first "word"
word1 = keyboard.next();

// grab the second "word"
word2 = keyboard.next();

// prompt for input from the keyboard
System.out.print("Enter another line: ");

// discard any remaining input from previous line
// and read the next line of input
anotherLine = keyboard.nextLine(); //skip to the next line
anotherLine = keyboard.nextLine(); //grab all of the next line

// output the strings
System.out.println("word1 = " + word1);
System.out.println("word2 = " + word2);
System.out.println("anotherLine = " + anotherLine);

Run Output:

Enter a line: Hello World! This will be discarded.
Enter another line: This line includes whitespace.
word1 = Hello
word2 = World!
anotherLine = This line includes whitespace.

Formatting Strings is done with the same style as using the printf() method discussed in Lesson A7, Simple I/O. In fact, now that you know more about Strings, you should be able to recognize that you are really manipulating String literals when you use the printf() formatting rules. If you want to alter how a String object is stored without actually printing it to the String, you can simply use a Formatter object (which is actually the object that printf() uses itself). An example of how to use Formatter is shown below. Note: Don’t forget to import the Formatter class.

import java.util.Formatter;

Formatter f = new Formatter();
f.format("%10s","Bob");
String bob = f.toString();
System.out.println(bob.length());
System.out.println(bob);

Run Output:

10
      Bob

When using the Formatter class, it is important to know that each time you operate on the Formatter object, the changes accumulate. For example, the following code formats the same object twice and therefore accumulates the same changes twice:

import java.util.Formatter;

Formatter f = new Formatter();
f.format("%5s","Bob");
String bob = f.toString();
System.out.println(bob);

f.format("%5s","Bob");
bob = f.toString();
System.out.println(bob);
,br>Run Output:

Bob
  Bob  Bob
  

If you don't want this effect, then you can instantiate a new Formatter object each time you want to reset the formatting. For example,

import java.util.Formatter;

Formatter f = new Formatter();
f.format("%5s","Bob");
String bob = f.toString();
System.out.println(bob);

f = new Formatter();

f.format("%5s","Bob");
bob = f.toString();
System.out.println(bob);

Run Output:

Bob
  Bob
  
Single Inheritance
Inheritance enables you to define a new class based on a class that already exists. The new class will inherit the characteristics of the existing class, but may also provide some additional capabilities. This makes programming easier, because you can reuse and extend your previous work and avoid duplication of code.

The class that is used as a basis for defining a new class is called a superclass (or parent class or base class). The new class based on the superclass is called a subclass (or child class or derived class.)

The process by which a subclass inherits characteristics from just one parent class is called single inheritance. Some languages allow a derived class to inherit from more than one parent class in a process called multiple inheritance. Multiple inheritance makes it difficult to determine which class will contribute what characteristics to the child class. Java avoids these issues by only providing support for single inheritance.

Figure 11.1 shows a superclass and a subclass. The line between them shows the "is a" relationship. The picture can be read as "a Student is a Person." The clouds represent the classes. That is, the picture does not show any particular Student or any particular Person, but shows that the class Student is a subclass of the Person class.



Inheritance is between classes, not between objects. A superclass is a blueprint that is followed when a new object is constructed. That newly constructed object is another blueprint that looks much like the original, but with added features. The subclass in turn can be used to construct objects that look like the superclass’s objects, but with additional capabilities.



Figure 11.2 shows a superclass and a subclass, and some objects that have been constructed from each. These objects that are shown as rectangles are actual instances of the class. In the picture, Albert Einstein, Lynne Brooke, and Monty Vista represent actual objects.

Class Hierarchies
In a hierarchy, each class has at most one superclass, but might have several subclasses. There is one class, at the top of the hierarchy that has no superclass. This is sometimes called the root of the hierarchy.



Figure 11.3 shows a hierarchy of classes. It shows that a Principal is a Person, a Student is a Person, and that a Teacher is a Person. It also shows that both HighSchoolStudent and CollegeStudent are types of Student.

In our example, the class Person is the base class and the classes Principal, Student, Teacher, HighSchoolStudent, and CollegeStudent are derived classes.

In Java, the syntax for deriving a child class from a parent class is:

class subclass extends superclass{
    // new characteristics of the subclass go here
}

Several classes are often subclasses of the same class. A subclass may in turn become a parent class for a new subclass. This means that inheritance can extend over several "generations" of classes. This is shown in Figure 11.3, where class HighSchoolStudent is a subclass of class Student, which is itself a subclass of the Person class. In this case, class HighSchoolStudent is considered to be a subclass of the Person class, even though it is not a direct subclass.

In Java, every class that does not specifically extend another class is a subclass of the class Object. For example, in Figure 11.3, the Person class extends the class Object. The class Object has a small number of methods that make sense for all objects, such as the toString method, but the class Object’s implementations of these methods are not very useful and the implementations usually get redefined in classes lower in the hierarchy.

Using Inheritance
The following program uses a class Person to represent people you might find at a school. The Person class has basic information in it, such as name, age and gender. An additional class, Student, is created that is similar to Person, but has the Id number and grade point average of the student.

public class Person{
  private String myName;   // name of the person
  private int myAge;       // person's age
  private String myGender; // "M" for male, "F" for female, "NB" for non-binary

  // constructor
  public Person(String name, int age, String gender){
    myName = name;
    myAge = age;
    myGender = gender;
  }

  public String getName(){
    return myName;
  }

  public int getAge(){
    return myAge;
  }

  public String getGender(){
    return myGender;
  }

  public void setName(String name){
    myName = name;
  }

  public void setAge(int age){
    myAge = age;
  }

  public void setGender(String gender){
    myGender = gender;
  }

  public String toString(){
    return myName + “, age: “ + myAge + “, gender: “
      + myGender;
  }
}

//-----------------End of Person Class-----------------//

public class Student extends Person{
  private String myIdNum; // Student Id Number
  private double myGPA; // grade point average

  // constructor
  public Student(String name, int age, String gender,
                                String idNum, double gpa){
    // use the super class' constructor
    super(name, age, gender);

    // initialize what's new to Student
    myIdNum = idNum;
    myGPA = gpa;
  }

  public String getIdNum(){
    return myIdNum;
  }

  public double getGPA(){
    return myGPA;
  }

  public void setIdNum(String idNum){
    myIdNum = idNum;
  }

  public void setGPA(double gpa){
    myGPA = gpa;
  }
}

//-----------------End of Student Class-----------------//

public class HighSchool{
  public static void main (String args[]){
    Person bob = new Person("Coach Bob", 27, "M");
    Student lynne = new Student("Lynne Brooke", 16, "F",
                                "HS95129", 3.5);
    System.out.println(bob);
    System.out.println(lynne);
    // The previous two lines could have been written as:
    // System.out.println(bob.toString());
    // System.out.println(lynne.toString());
  }
}

The Student class is a derived class (subclass) of Person. An object of type Student contains myIdNum and myGPA, which are defined in Student. It also has indirect access to the private variables myName, myAge, and myGender from Person through the methods getName(), getAge(), getGender(), setName(), setAge(), and setGender() that it inherits from Person.

The constructor for the Student class initializes the instance data of Student objects and uses the Person class’s constructor to initialize the data of the Person superclass. The constructor for the Student class looks like this:

// constructor
public Student(String name, int age, String gender,
               String idNum, double gpa){
   // use the super class's constructor
   super(name, age, gender);

   // initialize what's new to Student
   myIdNum = idNum;
   myGPA = gpa;
}

The statement super(name, age, gender) invokes the Person class’s constructor to initialize the inherited data in the superclass. The next two statements initialize the members that only Student has. Note that when super is used in a constructor, it must be the first statement.

So far, we have only seen the public (class members that can be accessed outside the class) and private (class members that are inaccessible from outside the class) access modifiers. There is a third access modifier that can be applied to an instance variable or method. If it is declared to be protected, then it can be used in the class in which it is defined and in any subclass of that class. This declaration is less restrictive than private and more restrictive than public. The A.P. Java subset allows the use of protected with methods but discourages its use for instance variables. It is preferred that all instance variables are private. Indirect access from subclasses should be done with public "getter" and "setter" methods. While protected members are available to provide a foundation for the subclasses to build on, they are still invisible to the public at large.

Method Overriding
A derived class can override a method from its base class by defining a replacement method with the same signature. For example, in our Student subclass, the toString() method contained in the Person superclass does not reference the new variables that have been added to objects of type Student, so nothing new is printed out. We need a new toString() method in the class Student:

// overrides the toString method in the parent class
public String toString(){
  return getName() + ", age: " + getAge() + ", gender: "
          + getGender() + ", student id: " + myIdNum
          + ", gpa: " + myGPA;
}

A more efficient alternative is to use super to invoke the toString() method from the parent class while adding information unique to the Student subclass:

public String toString(){
    return super.toString() +
          ", student id: " + myIdNum + ", gpa: " + myGPA;
}

Even though the base class has a toString() method, the new definition of toString() in the derived class will override the base class’s version . The base class has its method, and the derived class has its own method with the same name. With the change in the Student class the following program will print out the full information for both items.

Person bob = new Person("Coach Bob", 27, "M");
Student lynne = new Student("Lynne Brooke", 16, "F", "HS95129", 3.5);

System.out.println(bob.toString());
System.out.println(lynne.toString());

The output to this block of code is:

Coach Bob, age: 27, gender: M
Lynne Brooke, age: 16, gender: F, student id: HS95129, gpa: 3.5

The line bob.toString() calls the toString() method defined in Person, and the line lynne.toString() calls the toString() method defined in Student.


Interfaces
In Java, an interface is a mechanism that unrelated objects use to interact with each other. Like a protocol, an interface specifies agreed-on behaviors and/or attributes.

The Person class and its class hierarchy define the attributes and behaviors of a person. But a person can interact with the world in other ways. For example, an employment program could manage a person at a school. An employment program isn't concerned with the kinds of items it handles as long as each item provides certain information, such as salary and employee ID. This interaction is enforced as a protocol of method definitions contained within an interface. The Employable interface would define, but not implement, methods that set and get the salary, assign an ID number, and so on.



To work in the employment program, the Teacher class must agree to this protocol by implementing the interface. To implement an interface, a class must implement all of the methods and attributes defined in the interface. In our example, the shared methods of the Employable interface would be implemented in the Teacher class.

In Java, an interface consists of a set of methods and/or methods, without any associated implementations. Here is an example of Java interface that defines the behaviors of “employability” described earlier:

public interface Employable{
  public double getSalary();
  public int getEmployeeID();

  public void setSalary(double salary);
  public void setEmployeeID(int id);
}

A class implements an interface by defining all the attributes and methods defined in the interface. implements is a reserved word. For example:

public class Teacher implements Employable{
  ...
  public double getSalary() { return mySalary; }
  public int getEmployeeID() { return myEmployeeID; }

  public void setSalary(double salary) { mySalary = salary; }
  public void setEmployeeID(int id) { myEmployeeID = id; }
}

A class can implement any number of interfaces. In fact, a class can both extend another class and implement one or more interfaces. So, we can have things like (assuming we have an interface named Californian)

public class Teacher extends Person implements Employable, Californian{
...
}

Interfaces are useful for the following:

Declaring a common set of methods that one or more classes are required to implement
Providing access to an object’s programming interface without revealing the details of its class.
Providing a relationship between dissimilar classes without imposing an unnatural class relationship.
You are not likely to need to write your own interfaces until you get to the point of writing fairly complex programs. However, there are a few interfaces that are used in important ways in Java’s standard packages. You’ll learn about some of these standard interfaces in future lessons.

The while Loop
The general form of a while statement is:

while (expression){
  statement;
}

As in the if-else control structure, the boolean expression must be enclosed in parentheses ().

The statement executed by the while loop can be a simple statement, or a compound statement blocked with braces {}.

If the expression is true, the statement is executed. After execution of the statement, program control returns to the top of the while construct. The statement will continue to be executed until the expression evaluates to false.

The following diagram illustrates the flow of control in a while loop:




The following loop will print out the integers from 1-10.

int number = 1;               // initialize

while (number <= 10){         // loop boundary condition
  System.out.println(number);
  number++;                   // increment/decrement
}

The above example has three key lines that need emphasis.

You must initialize the loop control variable. If you do not initialize number, Java produces an error message warning you that the variable may not have been initialized.

The loop boundary conditional test (number <= 10) is often a source of error. Make sure that you have the correct comparison (<, >, ==, <=, >=, !=) and that the boundary value is correct. Programmers have to ensure that the loop is executed exactly the correct number of times. Performing the loop one too many or one too few times is called an OBOB , Off By One Bug.

There must be some type of increment/decrement or other statement so that execution of the loop eventually terminates, otherwise the program will get stuck in an infinite loop and never end!

It is possible for the body of a while loop to execute zero times. The while loop is an entry check loop. If the condition is false due to some initial value, the statement inside of the while loop will never happen. This is appropriate in some cases.

Loop Boundaries
The loop boundary is the boolean expression that evaluates as true or false. We must consider two aspects as we devise the loop boundary.

It must eventually become false, which allows the loop to exit.

It must be related to the task of the loop. When the task is done, the loop boundary must become false.

There are a variety of loop boundaries of which two will be discussed in this section.

The first is the idea of attaining a certain count or limit. The code in section A.4 above is an example of a count type of boundary.

Sample problem: In the margin to the left, write a program fragment that prints the even numbers 2-20. Use a while loop.

A second type of boundary construction involves the use of a sentinel value. In this category, the while loop continues until a specific value is entered as input. The loop watches out for this sentinel value, continuing to execute until this special value is input and then breaking out from the loop. You have already used the break statement for switch statements, and it has a similar use here. Once the loop encounters the break statement, all further checks of the boundary condition are ignored and code execution continues after the end of the while loop. For example, here is a loop that keeps a running total of non-zero integers, terminated by a value of zero.

Scanner in = new Scanner(System.in);
int total = 0;
int number;

while (true){
  System.out.print ("Enter a number (0 to quit) --> ");
  number = in.nextInt();
  if(number == 0){
    break;
  }else{
    total += number;
  }
}
System.out.println("Total = " + total);

Notice that because we don’t know how many times we want the loop to run, we simply declare the boundary condition as always true. This means the loop will run until we tell it to stop with the break command.

A similar construct to the break statement is the continue statement. When a loop encounters a continue statement, every statement left to execute in that specific iteration is ignored. The loop will then go back to check its boundary condition like normal. Continue statements can be useful for ignoring special cases (such as if you want to ignore an entry of zero in a loop that may use that number as a divisor).

Conditional Loop Strategies
This section will present a variety of strategies that assist the novice programmer in developing correct while loops. The problem to be solved is described first. Problem statement:

A program will read integer test scores from the keyboard until a negative value is typed in. The program will drop the lowest score from the total and print the average of the remaining scores.

One strategy in designing a while loop is to think about the following four sections of the loop: 1) initialization, 2) loop boundary, 3) contents of the loop and 4) the state of variables after the loop.

Initialization - Variables will usually need to be initialized before you get into the loop. This is especially true of while loops since the boundary condition is at the top of the control structure.

Loop boundary - You must construct a Boolean expression that becomes false when the problem is done. This is the most common source of error in coding a while loop. Be careful of off-by-one errors that cause the loop to happen one too few or one too many times.

Contents of the loop - This is where the problem is solved. The statement of the loop must also provide the opportunity to reach the loop boundary. If there is no movement toward the loop boundary, you will get stuck in an infinite loop.

State of variables after the loop - To ensure the correctness of your loop you must determine the status of key variables used in your loop. One way to do this is by tracing the code on paper.

We now solve the problem by first developing pseudocode.

Pseudocode:

initialize total and count to 0 initialize smallest to Integer.MAX_VALUE get first score while score is not a negative value increment total increment count change smallest if necessary get next score subtract smallest from total calculate average

And now it is easy to develop a working loop from this concise and easy to read pseudocode.

Tracing code is best done in a chart or table format. It keeps your data organized better than marking values all over the page. We now trace the following sample data input.

65 23 81 17 45 -1

score	score >= 0	total	count	smallest
undefined	undefined	0	0	INT_MAX
65	true	65	1	65
23	true	88	2	23
81	true	169	3	23
17	true	186	4	17
45	true	231	5	17
-1	false			
When the loop is terminated, the three key variables (total, score, and smallest) contain the correct answers.

The for Loop
The for loop has the same effect as a while loop, but uses a different format. The general form of a for loop is:

for (statement1; expression2; statement3){
  statement4;
}

The for loop is typically set up as follows.

statement1 initializes the loop variable expression2 is a boolean expression statement3 alters the key value, usually via an increment/decrement statement statement4 is the task to be done during each iteration

Here is an example of a for loop, used to print the integers 1-10.

for (int loop = 1; loop <= 10; loop++){
  System.out.print(loop);
}

The flow of control in a for loop is illustrated below:



Notice that after the statement is executed, control passes to the increment/decrement statement, and then back to the Boolean condition.

The following is the equivalent while loop:

int loop = 1;
while (loop <= 10){
  System.out.print( loop);
  loop++;
}

A for loop is appropriate when the initialization value and number of iterations is known in advance. The above example of printing 10 numbers is best solved with a for loop because the number of iterations of the loop is well defined.

Constructing a for loop is easier than a while loop because the key structural parts of a loop (initialization, loop boundary, and increment/decrement statement) are contained in one line. It is also easier to visually check the correctness of a for loop because it is so compact.

A while loop is more appropriate when the boundary condition is tied to some input or changing value inside of the loop.

Here is an interesting application of a for loop to print the alphabet:

char letter;

for (letter = 'A'; letter <= 'Z'; letter++){
  System.out.print(letter);
}

The increment statement letter++ will add one to the ASCII value of letter.

A simple, but time-consuming error to find and fix is the accidental use of a null statement.

for (loop = 1; loop <= 10; loop++); // note _;_
  System.out.print(loop);

The semicolon placed at the end of the first line causes the for loop to do "nothing" 10 times. The output statement will only happen once after the for loop has done the null statement 10 times. The null statement can be used as a valid statement in control structures. Make sure you pay attention to your enclosing {}.

There are two basic options for the variable used in the for loop. The variable can either be declared beforehand and therefore initially have a value set at another point in the program, or it can be declared and initialized within the for loop itself. Consider the following two for loops:

int number = 1;

for(; number <= 10; number++){
  System.out.println(number);
}

for(int a = 1; a <= 10; a++){
  System.out.println(a);
}

Notice how the first statement of the first for loop is blank. This is because the int variable number has already been declared and initialized. Blank statements within the for loop are allowed. Now, both for loops appear to do the exact same thing, printing out all the numbers from 1 to 10. However, there are several key differences. In the first example, number may be changed to any number desired during the run of the program. Instead of setting it to one, a programmer could set it to the value of a function such as int number = getValidNumber(). This gives additional power to the programmer. Another difference between the two loops is the scope of the variables number and a. Because number was declared outside of the for loop, the value of number may be used after the for loop. However, a was declared within the for loop and thus will not be usable past the end bracket of the for loop.

Nested Loops
To nest loops means to place one loop inside of another loop. The statement of the outer loop will be another inner loop. The following example will print a rectangular grid of stars with 4 rows and 8 columns.

for (int row = 1; row <= 4; row++){
  for (int col=1; col <= 8; col++){
    System.out.print("*");
  }
  System.out.println( );
}

Run Output:

********
********
********
********

For each occurrence of the outer row loop, the inner col loop will print 8 stars, terminated by the newline character.

The action of nested loops can be analyzed using a chart:

row	col
1	1 to 8
2	1 to 8
3	1 to 8
4	1 to 8
Suppose we wanted to write a method that prints out the following 7-line pattern of stars:

*******
 ******
  *****
   ****
    ***
     **
      *

Here is an analysis of the problem, line-by-line.

Line #	# spaces	# stars
1	0	7
2	1	6
3	2	5
...		
7	6	1
L	L - 1	N - L + 1
For a picture of N lines, each line L will have (L-1) spaces and (N-L+1) stars.

Here is a pseudocode version of the method.

A method to print a pattern of stars:

Print N lines of stars, each Line L consists of (L-1) spaces (N-L+1) stars a line feed

Here is the code version of the method.

void picture (int n){
  int line, spaces, stars, loop;

  for (line = 1; line <= n; line++){
    spaces = line - 1;
    for (loop = 1; loop <= spaces; loop++){
      System.out.print (" "); // print a blank space
    }
    stars = n - line + 1;
    for (loop = 1; loop <= stars; loop++){
      System.out.print ("*");
    }
    System.out.println();
  }
}

The do-while Loop (Optional)
There are conditional looping situations where it is desirable to have the loop execute at least once, and then evaluate an exit expression at the end of the loop.

The do-while loop allows you to do a statement first, and then evaluate an exit condition. The do-while loop complements the while loop that evaluates the exit expression at the top of the loop.

The general form of a do-while loop is:

do{
    statement;
}while (expression);

The flow of control for a do-while loop is illustrated:



The following fragment of code will keep a running total of integers, terminated by a sentinel zero value.

int number, total = 0;
do{
  System.out.print("Enter an integer (0 to quit) --> ");
  number = in.readInt();
  total += number;
}while (number != 0);

In contrast to the while loop version, the do-while has the advantage of using only one input statement inside of the loop. Because the Boolean condition is at the bottom, you must pass through the main body of a do-while loop at least once.

The same strategies used to develop while loops apply to do-while loops. Make sure you think about the following four sections of the loop: initialization, loop boundary, contents of the loop, and the state of variables after the loop.

Choosing a Loop Control Structure
If you know how many times a loop is to occur, use a for loop. Problems that require execution of a pre-determined number of loops should be solved with a for statement.

See Handout A12.1, Programming Pointers

The key difference between a while and do-while loop is the location of the boundary condition. In a while loop, the boundary condition is located at the top of the loop. Potentially, the statements within a while loop could happen zero times. If it is possible for the algorithm to occur zero times, use a while loop.

Because a do-while loop has its boundary condition at the bottom of the loop, the loop body must occur at least once. If the nature of the problem being solved requires at least one pass through the loop, use a do-while loop.

Loop Invariants
A loop invariant is an assertion about the loop that is relevant to the purpose of the loop. It is a precise statement, in terms of the loop variables, of what is true before and after each iteration of the loop.

Loop invariants are used to reason about programs formally and to prove their correctness without tracing all the iterations through a loop. If you can establish that an assertion is true the first time the loop is evaluated as well as after each iteration of the loop body, then your assertion is a loop invariant.

Consider the following code segment. Note that count! means the factorial of count.

int factorial (int num){
  int product = 1;
  int count = 0;

  while (count < num){ // invariant: product == count!
    count += 1;
    product *= count;
  }
  return product;
}

Each time that the loop test is evaluated, the value of the variable product is always equal to (count)!. Since 0! = 1 (by definition), this is true the first time the loop test is evaluated as well as after each iteration of the loop body. Since product == count! is true each time the loop test is evaluated, it is the loop invariant—the truth of the statement does not vary or change. Loop invariants are useful in reasoning about the correctness of programs that use loops. Since product == count! is an invariant, and product is returned, we can reason that the factorial method calculates the correct value.


Preconditions and Postconditions
In Lesson 4, we talked about method signatures. Method signatures specify a list of parameters data types that a method expects to receive when it is called. For example, consider the familiar Math method signature

sqrt(double)

It is illegal to call this method using sqrt(String) because the method is not defined for String arguments. A compiler error will result.

Knowing the sqrt() method accepts doubles is not enough though. There are further requirements that must be true in order for the method to work properly. In particular, the input must be a non-negative double.

Preconditions
A precondition is a statement of everything that must be true when a method is called in order for the method to work properly.

In the case of sqrt(double), the precondition is: input must be a non-negative double. If a precondition is met and the method body is error-free, the method is guaranteed to work properly.

Postconditions
A postcondition is a statement of everything that is true when a method completes its job.

The postcondition for sqrt(double) is that the square root of the input is returned.

It is important to document preconditions and postconditions as your programs become more complex. Preconditions go beyond parameter lists:

Does your method depend on the state of an instance variable?
Are you expecting one method to be called before another one?
Does your method work only for a certain range within the parameter data types?
Anyone who uses your classes will need to know this information as well as the postcondition of what is true when your method completes its task. Likewise, postconditions go beyond return values:

Does your method modify an instance variable?
Does your method modify the contents of its input arguments? You need to say so if it does.
For the labs in this lesson and thereafter you will be required to state each method's pre and post conditions whenever

A method works only for a range of values less than its declared data type
A method makes any assumptions in order to work properly
Here's an example. A precondition statement is needed because the method only works properly if the preconditions have been met.

/**
* Precondition:  initialize() has been called
*                playerName is defined,
*                gameLevel is an integer from 1 (easy) to 5 (hard)
*                m >= 3, n >=3
*
* Postcondition: a new m by n tic-tac-toe board is displayed in the console
*                window along with the player's name and difficulty level.
**/
void startGame(int m, int n) {
     < method body >
}

Failure to provide preconditions and handle precondition violations led to a $500-million software error in 1996. You can read about the fate of the European Ariane 5 launcher here. Fortunately, Java provides a means for dealing with precondition violations and run-time errors.

Exceptions
When a Java program performs an illegal operation, a special event known as an exception occurs.

An exception represents a problem that the compiler was unable to detect before the execution of the program. This is called a run-time error.

An example of this would be dividing by zero. The compiler often cannot tell before the program runs that a denominator would be zero at some later point and therefore cannot give an error before the program is run.
Exceptions In Java
In Java, an exception is an object that holds information about a run-time error.

The programmer can choose to ignore the exception, fix the problem and continue processing, or abort the execution of the code.

On the other hand, an error is when a program does not do what it was intended to do.

Compile time errors occur when the code entered into the computer is not valid.
Run-time errors happen when Java realizes during execution of the program that it cannot perform an operation.
Logic errors are when all the code compiles correctly but the logic behind the code is flawed.
Java provides a way for a program to detect that an exception has occurred and execute statements that are designed to deal with the problem. This process is called exception handling. If you do not deal with the exception, the program will stop execution completely and send an exception message to the console.

Common exceptions include:

ArithmeticException
NullPointerException
ArrayIndexOutOfBoundsException
ClassCastException
IOException
For example, if you try to divide by zero, this causes an ArithmeticException. Note that in the code section below, the second println() statement will not execute. Once the program reaches the divide by zero, the execution will be halted completely and a message will be sent to the console:

int numerator = 23; 

    int denominator = 0;
 

    // the following line produces an ArithmeticException  
    System.out.println(numerator/denominator);
 

    System.out.println(This text will not print);
    

A NullPointerException occurs if you use a null reference where you need an object reference. For example,

String name =  null;
 

    // the following line produces a NullPointerException  
    int i = name.length(); 

    System.out.println(This text will not print);
    

Since name has been declared to be a reference to a String and has the value null, indicating that it is not referring to any String at this time, an attempt to call a method within name, such as name.length(), will cause a NullPointerException. If you encounter this exception, look for an object that has been declared but has not been instantiated.

Handling Exceptions
There are three ways of handling a possible exception occurrence (we say that the exception is thrown).

In some cases, such as when there is a possibility that a divide by zero exception might occur, the programmer has the option of 1) not dealing with the exception at all. This can be useful in situations where the programmer has already taken steps to ensure that a denominator never becomes zero.
The programmer may also attempt to 2) fix the problem or 3) skip over the problem. To do either of these, the programmer needs to catch any exception that may be thrown. To catch an exception, one must anticipate where the exception might occur and enclose that code in a try block. The try block is followed by a catch block that catches the exception (if it occurs) and performs the desired action.
try-catch
The general form of a try-catch statement is:

try{  
 // try-block  
}  catch  (/* exception-type identifier */){  
 // catch-block  
}


The try-block refers to a statement or series of statements that might throw an exception. If no exception is thrown, all of the statements within the try-block will be executed. Once an exception is thrown, however, all of the statements following the exception in the try-block will be skipped.

The catch-block refers to a statement or series of statements to be executed if the exception is thrown. A try block can be followed by more than one catch block. When an exception is thrown inside a try block, the first matching catch block will handle the exception.

exception-type specifies what kind of exception object the catch block should handle. This can be specific, or it can be general, i.e. IOException or just Exception. Exception by itself will catch any type of exception that comes its way.

identifier is an arbitrary variable name used to refer to the exception-type object. Any operations done on the exception object or any methods called will use this identifier.

The try and catch blocks work in a very similar manner to the if-else statement and can be placed anywhere that normal code can be placed.

If an exception is thrown anywhere in the try block which matches one of the exception-types named in a catch block, then the code in the appropriate catch block is executed. If the try block executes normally, without an exception, the catch block is ignored.

Here is an example of try and catch:

int quotient;  
int numerator = 23;  
int denominator = 0;  
try{  
    quotient = numerator/denominator;  
    System.out.println("The answer is: " + quotient);  
}  catch  (ArithmeticException e){  
    System.out.println("Error: Division by zero");  
}


The value of denominator is zero so an ArithmeticException will be thrown whenever numerator is divided by denominator. The catch block will catch the exception and print an error message.
The println() statement in the try block will not be executed because the exception occurs before the program reaches that line of code. Once an exception is encountered, the rest of the lines of code in the try-block will be ignored.
If the value of denominator is not zero, the code in the catch block will be ignored and the println() statement will output the result of the division. Either way, the program continues executing at the next statement after the catch block.

Exception Messages
If a program does not handle exceptions at all, it will stop the program and produce a message that describes the exception and where it happened. This information can be used to help track down the cause of a problem.

The code shown below throws an ArithmeticException when the program tries to divide by zero. The program crashes and prints out information about the exception:

int numerator = 23;  
int denominator = 0;

// the following line produces an ArithmeticException  
System.out.println(numerator/denominator);
System.out.println("This text will not print");

Run Output:_

Exception in thread "main" java.lang.ArithmeticException: / by zero  
    at DivideByZero.main(DivideByZero.java:10)


The first line of the output tells which exception was thrown and gives some information about why it was thrown.
“DivideByZero.main” indicates that the exception occurred in the main method of the DivideByZero class. In the parentheses, the specific file name and line number are given so that the programmer can find where their code went wrong (in the example above, the exception occurred on line 10 of a Java file, DivideByZero.java). This is the line where Java found a problem. The actual root cause of the problem may be a line or two ahead of line 10.
The rest of the output tells where the exception occurred and is referred to as a call stack trace. In this case, there is only one line in the call stack trace, but there could be several, depending on where the exception originated.

When exceptions are handled by a program, it is possible to obtain information about an exception by referring to the “exception object” that Java creates in response to an exception condition. Every exception object contains a String that can be accessed using the getMessage method as follows:

try{  
    quotient = numerator/denominator;  
    System.out.println("The answer is: " + quotient);  
}  catch  (ArithmeticException e){  
    System.out.println(e.getMessage());  
}
If a divide by zero error occurs, an exception is thrown and the following message is displayed:

/ by zero


Printing the value returned by getMessage can be useful in situations where we are unsure of the type of error or its cause.

If an exception is unknown by your Java class, you may need to import the appropriate exception (just like you would import any other class you wanted your class to know about).

For example, the ArithmeticException is a standard Java class and no import statement is needed for it. However, IOException is part of the java.io package and must therefore be imported before it is used.

Throwing Exceptions
There are times when it makes sense for a program to deliberately throw an exception. This is the case when the program discovers some sort of exception or error condition, but there is no reasonable way to handle the error at the point where the problem is discovered. The program can throw an exception in the hope that some other part of the program will catch and handle the exception.

To throw an exception use a throw statement. This is usually done with an if statement. The syntax of the throw statement is:

throw exception-object;

For example, the following statement throws an ArithmeticException:

if(number == 0){  
    throw new ArithmeticException("Division by zero");  
}

The exception object is created with the new operator right in the throw statement. Exception classes in Java have a default constructor that takes no arguments and a constructor that takes a single String argument. If provided, this String appears in the exception message when the exception occurs.

Reading From File
Reading textual data from a file is very similar in many ways to reading input from the keyboard. The Scanner class and all of its methods remain the same. However, you must also import the classes java.io.File and java.io.IOException. Also, the way in which you use the Scanner class constructor changes.

The java.io.File is a holder class that can take a String representing the path to a file on your computer. Creating a Scanner object that reads from a file is as simple as:

Scanner in =  new Scanner(new File(“test.txt”));  
File f =  new File(“C:\MyDocuments\Java\tester.txt”);  
Scanner in2 =  new Scanner(f);


The first line assumes that there is a file named “test.txt” in the directory or folder where you run your Java files.
The second line shows an example of creating the File object in its own line of code. It also shows the File being created with the full path to the file. This would be used if your text file was not in the same directory as your Java files.
But what happens if the file that you are looking for doesn’t exist or has some other status that prevents it from being read? This causes an exception to be thrown!
Scanner will take no responsibility in handling the exception, so every time that you want to use Scanner with a file, you will have to use a try-catch block. A full example is shown below:

Scanner in;  
try{  
    in = new Scanner(new File("test.txt"));  
    String test = in.nextLine();  
    System.out.println(test);  
}catch(IOException i){  
    System.out.println("Error: " + i.getMessage());  
}

When reading a large amount of data from a file, it is often useful to know whether there is any more data in the file to read.

Reading from a file which has no more data will give you a NoSuchElementException and stop your program. The Scanner class has several methods for determining if there is any more data in the file to be read: hasNext(), hasNextDouble(), and hasNextInt( will be the methods most useful for you.
If there is anything still to come, hasNext() will return true, while hasNextDouble() will return true only if a valid double is next and hasNextInt() will return true only if an int value is next. Using a simple while loop, you can easily read in data until the end of a file.
while(in.hasNext()){  
    System.out.println(in.next());  
}

Writing to a File
Writing to your own files is a little bit trickier than reading from them. There are two basic ways to write data to files: raw bytes and character streams. Raw byte writing is useful for items such as pictures. Character streams are used for writing plain text. This curriculum will focus only on character streams.

This curriculum uses the java.io.FileWriter class.

It has two basic constructors:

FileWriter file = new FileWriter(“test.txt”); FileWriter file2 = new FileWriter(“test2.txt”, true);

The first constructor opens a basic FileWriter object that points at the file “test.txt” in the same directory where the Java files are being run. When this file is first opened and written to, all of the data that was previously stored in the file will be erased.
The second constructor indicates that the new data being sent to the file will be appended to the end of the file. In either case, if the file does not exist, then Java will attempt to create a new file with the indicated name and at the indicated location.
Writing data
Writing data to the file is done by using the FileWriter.write(String, int, int) method.

The String is the data that will be written to the file. The first int is where to start writing the data in the String. The second int indicates how many characters of the String to actually write. For example:

String one = “#Hello!!!”;  
FileWriter out =  new  FileWriter(“test.txt”);  
out.write(one, 1, 5);

This will write only “Hello” to the file “test.txt.”

Merely opening a file and writing to it is not enough to store your data in most cases. You know from personal experience that if you don’t save your work in a word processor, your work will not be there the next time you start up your computer. Data must be saved. This is done with FileWriter by calling the close() method when you are done writing data. This “closes” the output stream to the file and saves your data.

Out.write(one, 1, 5);  
Out.close();

What if there is some error in opening the file? That’s right - an exception is thrown and it must be dealt with just like in the Scanner class.

String one = “Hello World!!!”;  
FileWriter out;  
try{  
    out = new FileWriter(“test.txt”);  
    out.write(one, 0, one.length());  
    out.close();  
} catch (IOException i){  
    System.out.println(“Error: “ + i.getMessage());  
}


There is no equivalent to println() with the FileWriter class, so any newlines that you wish to create must be done with the ‘\n’ character.
FileWriter only deals with writing String to the text files, which creates a little bit of a problem with writing numeric data. However, we can use the shortcut learned earlier in Lesson A10 - Strings to change our other data types to String.

String temp;  
int a = 5;  
temp = “” + a + “\n”;  
out.write(temp, 0, temp.length());  
double p = 3.14;  
temp = “” + p + “\n”;  
out.write(temp, 0, temp.length());  
boolean test = true;  
temp = “” + test + “\n”;  
out.write(temp, 0, temp.length());

Because FileWriter requires you to specify how many characters of the given String to print out, you must be careful with the values that you give it.

If the int value that you send is bigger than the String itself, you will get a StringIndexOutOfBoundsException when the FileWriter object tries to access characters in the String which do not exist.
An easy way to prevent this from ever occurring is to always create a String object before the write method is called with the data you wish to output, place that String in the call to write, and use that String’s length() method for how many characters to print.
String one = “Hello World!!!\n”; out.write(one, 0, one.length());

Negations of Boolean Assertions
A Boolean assertion is simply an expression that results in a true or false answer. For example,

a > 5

0 == b

a <= b

are all statements that will result in a true or false answer.

To negate a Boolean assertion means to write the opposite of a given Boolean assertion. For example, given the following Boolean assertions noted as A, the corresponding negated statements are the result of applying the ! operator to A.

A	!A
5 == x	5 != x
x < 5	x >= 5
x >= 5	x < 5

Notice that negations of Boolean assertions can be used to re-write code. For example:

if  (!(x < 5))  
    // do something...

can be rewritten as

if  (x >= 5)  
    // do something ...

This is important because we understand positive statements much more easily than statements that contain one or more !s.

Boolean Algebra and DeMorgan’s Laws
Boolean Algebra is a branch of mathematics devoted to the study of Boolean values and operators. Boolean Algebra consists of these fundamental operands and operators:

operands (values): true, false
operators: and (&&), or (||), not (!)
Note: Java has other Boolean operators, such as ^ (XOR - “exclusive or”) and equivalence. This curriculum does not cover these other operators because they are not part of the AP subset.

There are many identities that have been developed to use with compound Boolean expressions. Two of the more useful identities are DeMorgan's Laws, which are used to negate compound Boolean expressions.

DeMorgan’s Laws:

!(A || B) -> ! A && ! B

!(A && B) -> ! A || ! B


Here is a good way to think about both of DeMorgan’s Laws. Notice that it is similar to the distributive postulate in mathematics. The not operator is distributed through both terms inside of the parentheses, except that the operator switches from and to or, or vice versa.

!(A && B) -> ! A || ! B
!(A || B) -> ! A && ! B

Bubble Sort
Bubble Sort is the simplest of the three sorting algorithms, and also the slowest. The Bubble Sort gets its name from the way that the largest items “bubble” to the top (end). The procedure goes like this.

Move the largest remaining item in the current pass to the end of the data as follows. Starting with the first two items, swap them if necessary so that the larger item is after the smaller item. Now move over one position in the list and compare to the next item. Again swap the items if necessary.

Remove the largest item most recently found from the data to be searched and perform another pass with this new data at step 1.

Repeat steps 1 and 2 above until the number of items to be searched is one.

To see how Bubble Sort works, let’s try an example:

Steps	Data for Pass	Sorted data
Start pass 1: compare 4 & 1	4 1 3 2	
4 > 1 so swapped, now compare 4 & 3	1 4 3 2	
4 > 3 so swapped, now compare 4 & 2	1 3 4 2	
4 > 2 so swapped, end of pass	1 3 2 4	
Start pass 2: compare 1 & 3	1 3 2	4
3 > 1 so no swap, now compare 3 & 2	1 3 2	4
3 > 2 so swapped, end of pass	1 2 3	4
Start pass 3: now compare 1 & 2	1 2	3 4
2 > 1 so no swap	1 2	3 4
Only one item in this pass so it is done	1	2 3 4
Done.		1 2 3 4
The following program implements the Bubble Sort algorithm.

void bubbleSort(ArrayList <Integer> list){
  for (int outer = 0; outer < list.size() - 1; outer++){
    for (int inner = 0; inner < list.size()-outer-1; inner++){
      if (list.get(inner) > list.get(inner + 1)){
        //swap list[inner] & list[inner+1]
        int temp = list.get(inner);
        list.set(inner, list.get(inner + 1));
        list.set(inner + 1, temp);
      }
    }
  }
}

Given a list of 6 values, the loop variables outer and inner will evaluate as follows.

When outer	inner ranges from 0 to < (6 - outer - 1)
0	0 to 4
1	0 to 3
2	0 to 2
3	0 to 1
4	0 to 0

When outer = 0, then the inner loop will do 5 comparisons of pairs of values. As inner ranges from 0 to 4, it does the following comparisons:

inner	if (list.get(inner) > list.get(inner + 1))
0	if list[0] > list[1]
1	if list[1] > list[2]
...	...
4	if list[4] > list[5]

If (list.get(inner) > list.get(inner + 1)) is true, then the values are out of order and a swap takes place. The swap takes three lines of code and uses a temporary variable temp.

After the first pass (outer = 0), the largest value will be in its final resting place (and may it rest in peace). When outer = 1, the inner loop only goes from 0 to 3 because a comparison between positions 4 and 5 is unnecessary. The inner loop is shrinking.

Because of the presence of duplicate values, this algorithm will result in a list sorted in non-decreasing order.


Selection Sort
The Selection Sort also makes several passes through the list. On each pass, it compares each remaining item to the smallest (or largest) item that has been found so far in the pass. In the example below, the Selection Sort method finds the smallest item on each pass. At the end of a pass, the smallest item found is swapped with the last remaining item for that pass. Thus, swapping only occurs once for each pass. Reducing the number of swaps makes the algorithm more efficient.

The logic of Selection Sort is similar to Bubble Sort except that fewer swaps are executed.

void selectionSort(ArrayList <Integer> list){
  int min, temp;

  for (int outer = 0; outer < list.size() - 1; outer++){
    min = outer;
    for (int inner = outer + 1; inner < list.size(); inner++){
      if (list.get(inner) < list.get(min)) {
        min = inner; // a new smallest item is found
      }
    }
    //swap list[outer] & list[min]
    temp = list.get(outer);
    list.set(outer, list.get(min));
    list.set(min, temp);
  }
}

Again, assuming that we have a list of 6 numbers, the outer loop will range from 1 to 5. When outer = 1, we will look for the smallest value in the list and move it to the first position in the array.

However, when looking for the smallest value to place in position 1, we will not swap as we search through the list. The algorithm will check from indexes 1 to 5, keeping track of where the smallest value is found by saving the index of the smallest value in min. After we have found the location of the smallest value, we swap list[outer] and list[min].

By keeping track of where the smallest value is located and swapping only once, we have a more efficient algorithm than Bubble Sort.


Insertion Sort
Insertion Sort takes advantage of the following fact.

If A < B and B < C, then it follows that A < C. We can skip the comparison of A and C.

Consider the following partially sorted list of numbers.

2 5 8 3 9 7

The first three values of the list are sorted. The 4th value in the list, (3), needs to move back in the list between the 2 and 5.



This involves two tasks, finding the correct insert point and a right shift of any values between the start and insertion point.

The code follows.

void insertionSort(ArrayList <Integer> list){
  for (int outer = 1; outer < list.size(); outer++){
    int position = outer;
    int key = list.get(position);

    // Shift larger values to the right
    while (position > 0 && list.get(position - 1) > key){
      list.set(position, list.get(position - 1));
      position--;
    }
    list.set(position, key);
  }
}

By default, a list of one number is already sorted. Hence, the outer loop skips position 0 and ranges from positions 1 to list.size(). For the sake of discussion, let us assume a list of 6 numbers.

For each pass of outer, the algorithm will determine two things concerning the value stored in list[outer]. First, it finds the location where list[outer] needs to be inserted in the list. Second, it does a right shift on sections of the array to make room for the inserted value if necessary.

Constructing the inner while loop is an appropriate place to apply DeMorgan’s laws:

The inner while loop postcondition has two possibilities:
The value (key) is larger than its left neighbor.
The value (key) moves all the way back to position 0.

This can be summarized as:

(0 == position || list.get(position - 1) <= key)

If we negate the loop postcondition, we get the while loop boundary condition:

(0 != position && list.get(position - 1) > key)

This can also be rewritten as:

((position > 0) && (list.get(position - 1) > key))

The two halves of the boundary condition cover these situations:

(position > 0) -> we are still within the list, keep processing

list[position - 1] > key -> the value in list[pos-1] is larger than key, keep moving left (position--) to find the first value smaller than key.

The Insertion Sort algorithm is appropriate when a list of data is kept in sorted order with infrequent changes. If a new piece of data is added, probably at the end of the list, it will get quickly inserted into the correct position in the list. Many of the other values in the list do not move and the inner while loop will not be used except when inserting a new value into the list.


Counting Steps
These three sorting algorithms are categorized as quadratic sorts because the number of steps increases as a quadratic function of the size of the list.

In order to compare algorithms to see this for yourself, we will come up with a way to count the steps each algorithm takes to solve a problem. Then we can see how the steps increase when the number of items to process increases. For example, if it took 100 steps to process 10 items, but it took 400 steps to process 20 items, clearly the number of steps is not increasing linearly with the number of items. We will add code to the sorting template program and count the number of steps for each algorithm so we can collect this data.

In Lab 17.4 QuadSort, we will use an instance variable called steps to keep track of the number of steps executed. The steps variable will be maintained within the Sorts class. The starter code for the SortStep class already resets the steps count to 0 before a sort is run, so the code in the Sorts class can assume steps will be zero when a sorting method is called.

Which Steps To Count
While it is possible to use a variety of rules for what to count, the simplest rule is to just count everything: assignments, comparisons, math operations, method calls, increments, decrements...etc.

The increment and decrement operators will each count as a single step because they are optimized to be more efficient than a separate assignment and addition. Thus x++ counts as one step even though x = x + 1 would count as 2 steps (= and +).

We will treat referencing a value in an array the same as accessing the value in a variable since it is not a method call so just accessing the value will be free. We will count calls to the get(int) method of ArrayList as one step because it is a method call and therefore comes with the overhead of adding the method call to the stack and doing a range check, so it is slower than directly accessing an index in an array. In both cases, any calculations done to determine the index will of course count as steps because they are math operations and any operations such as assignment or comparison will still count as steps.

Similarly, the array property length is not a method, so arr.length will be treated the same as accessing the value of a variable and won't count as a step, but the ArrayList method size() is a method call, so list.size() would count as one step.

In the example below, the method is swapping the values on each side of index i.

public void swapNeighbors(int[] arr, int i) {
  int left = arr[i - 1];
  arr[i - 1] = arr[i + 1];
  arr[i + 1] = left;
}
Now, lets count the steps.

+2 steps for int left = arr[i - 1] ( +1 for assignment = and +1 for math op i - 1)
+3 steps for arr[i - 1] = arr[i + 1] (+1 for i - 1, +1 for =, and +1 for i + 1)
+2 steps for arr[i + 1] = left (+1 for i + 1 and +1 for =)
That is 7 steps. We could write the step counting like this:

public void swapNeighbors(int[] arr, int i) {
  steps += 2; // =, -
  int left = arr[i - 1];
  steps += 3; // -, =, +
  arr[i - 1] = arr[i + 1];
  steps += 2; // +, =
  arr[i + 1] = left;
}
It is good practice to include a comment noting what was counted, so it is easy to confirm the counting was done correctly.

Since all the operations in swapNeighbors will be executed each time the method is called, we can combine them into a single statement that counts all those steps.

public void swapNeighbors(int[] arr, int i) {
  steps += 7; // =, -, -, =, +, +, =
  int left = arr[i - 1];
  arr[i - 1] = arr[i + 1];
  arr[i + 1] = left;
}
Step Counting With Conditional Statements
Sometimes there are conditional statements that control when code runs, so not all lines of code will be guaranteed to run each time. For example, the swapNeighbors method as written above would throw an IndexOutOfBoundsExeption in certain cases, so a better implementation would include boundary checks to prevent that from happening. To do that, we need to decide how it will handle the edges. Let's say we add a rule that says the method will do nothing if the index passed in is the first or last index in the array. We could then modify the method like this:

public void swapNeighbors(int[] arr, int i) {
  if (i > 0 && i < arr.length - 1) {
    int left = arr[i - 1];
    arr[i - 1] = arr[i + 1];
    arr[i + 1] = left;
  }
}
Since there is now some code that only runs in certain conditions, we need to make sure that steps are only counted when they are guaranteed to be executed.

The comparison in the first condition of the if statement (i > 0) is guaranteed to be executed regardless of whether it evaluates to true or not, so we can count that step just before the if statement like this:

public void swapNeighbors(int[] arr, int i) {
  steps++; // i > 0 comparison
  if (i > 0 && i < arr.length - 1) {
    int left = arr[i - 1];
    arr[i - 1] = arr[i + 1];
    arr[i + 1] = left;
  }
}
The if statement has an && in the condition, which means that due to boolean short circuiting, the second condition will only be checked if the first one is true. To handle that, you can simply add conditional logic to your step counting that only counts the steps in the second condition if the first one is true.

public void swapNeighbors(int[] arr, int i) {
  steps++; // i > 0 comparison
  if (i > 0) steps + = 2 // i < arr.length - 1 is two operations: < and -
  if (i > 0 && i < arr.length - 1) {
    int left = arr[i - 1];
    arr[i - 1] = arr[i + 1];
    arr[i + 1] = left;
  }
}
Now that we are ready to count the steps inside the if statement. To be sure the steps are only counted when the if condition is true, we simply put the step counting code for those operations inside the if statement. We already went over those steps earlier and figured out there are 7 steps, so we can just write the previous step counting code inside the body of the if statement:

public void swapNeighbors(int[] arr, int i) {
  steps++; // i > 0 comparison
  if (i > 0) steps + = 2 // i < arr.length - 1 is two operations: < and -
  if (i > 0 && i < arr.length - 1) {
    steps += 7; // =, -, -, =, +, +, =
    int left = arr[i - 1];
    arr[i - 1] = arr[i + 1];
    arr[i + 1] = left;
  }
}
Step Counting With Loops
A while loop is like an if statement that repeats, so you should count the steps for the condition before the while loop, just like you would for an if statement; however, you should also count the steps for the condition at the end of the body of the loop because when the body of the loop is completed, the condition will be checked again.

Lets say we had the following code segment. Assume x, n and list have already been declared and initialized.

while (x < n) {
  x++;
  n--;
  list.add(n);
}
We would add step counting code like this:

steps++; // x < n comparison
while (x < n) {
  steps += 3; // x++, n--, add()
  x++;
  n--;
  list.add(n);
  steps++; // x < n comparison
}
A for loop is similar to a while loop, except that there are more parts to it. The parts of a for loop are:

for (initialization; condition; change) {
  body
}
When a for loop is encountered:

The initialization is executed exactly once in all cases.
The condition will execute after the initialization regardless of whether the condition is true.
The body will only execute after the condition is checked only if the condition is true.
The change will always execute after the body.
The condition will always execute after the change.
Lets take a specific example. Assume list has already been declared and initialized:

for (int i = 0; i < list.size() - 1; i++) {
  if (list.get(i).compareTo(list.get(i + 1)) > 0) {
    Comparable temp = list.get(i);
    list.set(i, list.get(i + 1));
    list.set(i + 1, temp)
  }
}
According to the rules above, we can start by counting the initialization and condition before the loop like this:

steps += 4; // =, <, size(), - (initialization and comparison)
for (int i = 0; i < list.size() - 1; i++) {
  if (list.get(i).compareTo(list.get(i + 1)) > 0) {
    Comparable temp = list.get(i);
    list.set(i, list.get(i + 1));
    list.set(i + 1, temp)
  }
}
Inside the body of the for loop, there is an if statement. We can count the steps in the condition before the if statement as we discussed earlier:

steps += 4; // =, <, size(), - (initialization and comparison)
for (int i = 0; i < list.size() - 1; i++) {
  steps += 5; // get(), compareTo(), get(), +, >
  if (list.get(i).compareTo(list.get(i + 1)) > 0) {
    Comparable temp = list.get(i);
    list.set(i, list.get(i + 1));
    list.set(i + 1, temp)
  }
}
Then we can count the steps inside the body of the if statement:

steps += 4; // =, <, size(), - (initialization and comparison)
for (int i = 0; i < list.size() - 1; i++) {
  steps += 5; // get(), compareTo(), get(), +, >
  if (list.get(i).compareTo(list.get(i + 1)) > 0) {
    steps += 7; // =, get(), set(), get(), +, set(), +
    Comparable temp = list.get(i);
    list.set(i, list.get(i + 1));
    list.set(i + 1, temp)
  }
}
Finally, at the end of the body, after the if statement, we can count the steps in the change and the condition which will decide whether another iteration occurs.

steps += 4; // =, <, size(), -  (initialization and comparison)
for (int i = 0; i < list.size() - 1; i++) {
  steps += 5; // get(), compareTo(), get(), +, > (the if condition)
  if (list.get(i).compareTo(list.get(i + 1)) > 0) {
    steps += 7; // =, get(), set(), get(), +, set(), + (the if body)
    Comparable temp = list.get(i);
    list.set(i, list.get(i + 1));
    list.set(i + 1, temp)
  }
  steps += 4; // i++, <, size(), - (change and comparison)
}
Bubble Sort Example
Here is an example of adding step counting to a bubbleSort method:

public void bubbleSort(ArrayList <Comparable> list){
  steps += 4; // =, <, size(), - (outer loop inititalization and condition)
  for (int outer = 0; outer < list.size() - 1; outer++){
    steps += 5; // =, <, size(), -, - (inner loop initialization and condition)
    for (int inner = 0; inner < list.size()-outer-1; inner++){
      steps += 5; // get(), compareTo(), get(), +, > (if condition)
      if (list.get(inner).compareTo(list.get(inner + 1)) > 0){
        steps += 7; // =, get(), set(), get(), +, set(), + (if body)
        Comparable temp = list.get(inner);
        list.set(inner,list.get(inner + 1));
        list.set(inner + 1,temp);
      }
      steps += 5; // inner++, <, size(), -, - (inner loop change and condition)
    }
    steps += 4; // outer++, <, size(), - (outer loop change and condition)
  }
}
As you count the number of steps, an interesting result will show up in your data. As the size of the data set doubles, the number of steps executed increases by approximately four times, a “quadratic” rate.

Bubble Sort is an example of a quadratic algorithm in which the number of steps required increases at a quadratic rate as the size of the data set increases.

A quadratic equation in algebra is one with a squared term, like x2. In our sorting example, as the size of the array increases to N, the number of steps required for any of the quadratic sorts increases as a function of N2.

Warning About Calling Methods
The method calls we counted in the examples above are all simple methods like get() and set() that perform essentially one operation, so it makes sense to count them as one step, but you should always consider what a method does when counting steps. For example, calling list.remove(0) will not just remove the first item, it will also shift all the other items in the list to the left. If there were 100 items in the list, that is equivalent to 99 calls of set on top of any math ops, so it would be a huge mistake to count that as a single step. If you are calling your own helper method, such as a swap method, simply add step counting to the helper method as we did for swapNeighbors, otherwise you will need to figure out a fair estimate of the number of steps the method will execute based on what it does.

When doing Lab 17.4 QuadSort, you should only use the methods get() and set(), so you should not run in to this complication.


Sorting objects
Notice that the sorts we developed above know how to compare Integers. Comparison is built into the Integer class. What if we wanted to write a sort that could work on Strings? You cannot use ‘<’ on Strings. Remember you have to use the compareTo method.

To convert the BubbleSort, make the following changes that are highlighted in yellow.

void bubbleSort(ArrayList <String> list){
  for (int outer = 0; outer < list.length - 1; outer++){
    for (int inner = 0; inner < list.size()-outer-1; inner++){
      if (list.get(inner).compareTo(list.get(inner + 1) > 0)){
          //swap list[inner] & list[inner+1]
          String temp = list.get(inner);
          list.set(inner, list.get(inner + 1));
          list.set(inner + 1, temp);
      }
    }
  }
}

If I am able to sort my data, there must be an order defined for it. Classes that have an order should have a compareTo method. Java defines an Interface, Comparable, just for this purpose (see below for some information on Comparable). To make a BubbleSort that will work on any objects that implement Comparable, make the following changes, again highlighted in yellow.

void bubbleSort(ArrayList <Comparable> list){
  for (int outer = 0; outer < list.length - 1; outer++){
    for (int inner = 0; inner < list.size()-outer-1; inner++){
      if (list.get(inner).compareTo(list.get(inner + 1) > 0)){
          //swap list[inner] & list[inner+1]
          Comparable temp = list.get(inner);
          list.set(inner, list.get(inner + 1));
          list.set(inner + 1, temp);
      }
    }
  }
}

Now this method is quite reusable because we can use it to sort any Comparable object. The compareTo interface follows.

Interface java.lang.Comparable  
int compareTo(Object other)  
// returns value < 0 if this is less than other  
// returns value = 0 if this is equal to other  
// returns value > 0 if this is greater than other

Remember to consider whether or not it makes sense to compare objects that you build. If it does, implement the Comparable Interface. It would also make sense to provide an equals method for your class.

